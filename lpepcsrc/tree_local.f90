!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!>
!> Build the local tree structure, then find local branches,
!> after that compute properties up to branch level.
!>
!> The tree will be refined until every particle owns a cell
!> that contains no other particle. By this step additional cells
!> were introduced. (TODO: local fill nodes on the fly => global merge).
!> Level by level for every cell it will be differentiate between
!> twigs and leafs (node). Finally, for fast children computaion,
!> the childbyte will be updated.
!>
!> Possible branch candidates are generated by the branch-estimation.
!> If the candidate exists, it will added to the branch list.
!>
!> The branches are on different levels. For every branch the properties
!> are calculated.
!>
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine tree_local

  use treevars
  use timings
  use tree_utils
  use module_branching
  use module_htable
  use module_spacefilling
  use module_multipole_helpers

  implicit none
  include 'mpif.h'

  integer :: i, j, k, i1, i2, ierr, level_match, level_diff, ibit, iend, level, nbound, newleaf, nres, ncoll, &
       link_addr, ipoint, parent_addr, childbyte, treelevel, ncheck, nsubset, newsub, cchild, nchild, addr_leaf, &
       p_leaf, ntwig_domain, node_leaf, addr_twig, addr_child, nsearch
  integer*8 ::  key_lo, cell1, cell2, parent_key
  logical :: resolved

  integer*8, dimension(8) :: sub_key, key_child   ! Child partial key
  integer, dimension(8) :: node_child   

  integer*8, dimension(nppm+2) :: local_key
  integer, dimension(nppm+2)  :: local_plist, local_owner, local_ind
  integer*8, allocatable :: subcell(:)
  integer, allocatable :: cell_addr(:)
  integer*8, dimension(maxaddress) :: res_key,search_key, resolve_key
  integer, dimension(maxaddress) :: newentry, res_addr, res_node, res_child, res_owner
  type(t_multipole_data), pointer :: res

!!! --------------- TREE BUILD ---------------

 
  call timer_start(t_local)
  call timer_start(t_build)
  call timer_start(t_build_neigh)

  if (tree_debug) write(ipefile,'(/a)') 'TREE LOCAL'
  if (me==0 .and. tree_debug) write(*,'(a)') 'LPEPC | LOCAL BUILD'

  call htable_clear()

  do i=1,npp+2
     local_plist(i) = particles(i)%label       ! Particle (global) label for tracking purposes
     local_key(i)   = particles(i)%key           ! Particle key
     local_owner(i) = particles(i)%pid
  end do
  i=0                     ! List of free (unused #table-addresses) 

  !  Check whether boundary particles are close enough to warrant inclusion
  !  in tree construction.
  
  nlist = npp

  ! RH neighbour PE 
  if ( me /= num_pe-1 ) then
     ! First find level shared by last particle pair in list
     key_lo = ieor( particles(npp)%key, particles(npp-1)%key )   ! Picks out 1st position where keys differ
     level_diff =  level_from_key(key_lo)
     level_match = max( nlev - level_diff, 1 )    ! Excludes low-level end-cells for discontinuous domains
     ibit = nlev-level_match               ! bit shift factor 

     cell1 = ishft( particles(npp  )%key, -3*ibit )    ! Subcell number of RH boundary particle
     cell2 = ishft( particles(npp+1)%key, -3*ibit )    ! Subcell number of LH boundary particle of neighbouring PE
     if (cell1 == cell2) then
        nlist = nlist+1                    ! If keys match at this level then include boundary particle in local tree
        local_plist(nlist) = particles(npp+1)%label
        local_key(nlist)   = particles(npp+1)%key
        local_owner(nlist) = me+1
        if (build_debug) write (ipefile,'(a,i5,a)') 'boundary particle from PE',me+1,' included in list'
     endif

  endif

  ! 2nd set: LH neighbour PE
  if ( me /= 0 ) then
     iend = npp+2
     if ( me == num_pe-1 ) iend = npp+1         ! End node only has one boundary particle
     ! First find level shared by first particle pair in list
     key_lo = ieor( particles(1)%key, particles(2)%key  )   ! Picks out lower order bits where keys differ
     level_diff =  level_from_key(key_lo)

     level_match = max( nlev - level_diff, 1 )    ! Excludes low-level end-cells for discontinuous domains
     ibit = nlev-level_match               ! bit shift factor 

     cell1 = ishft( particles(   1)%key, -3*ibit )    ! Subcell number of LH boundary particle
     cell2 = ishft( particles(iend)%key, -3*ibit )    ! Subcell number of RH boundary particle of neighbouring PE
     if (cell1 == cell2) then
        nlist = nlist+1         ! If keys match at this level then include boundary particle in local tree
        local_plist(nlist) = particles(iend)%label
        local_key(nlist)   = particles(iend)%key
        local_owner(nlist) = me-1
        if (build_debug) write (ipefile,'(a,i5,a)') 'boundary particle from PE',me-1,' included in list'
     endif
  endif

  call timer_stop(t_build_neigh)
  call timer_start(t_build_part)

  allocate(subcell(1:nlist),cell_addr(1:nlist))

  call timer_start(t_build_pure)

  level = 0                        ! start at root
  local_ind(1:nlist) = (/(k,k=1,nlist)/) ! Sorted local particle index / leaf number: points to particle properties

  !  set up root node

  htable(1)%node   =  -1              !  node #
  htable(1)%owner  =  me              ! Owner
  htable(1)%key    =   1_8            !  key
  htable(1)%link   =  -1              !  collision link
  htable(1)%leaves = npp              ! root contains all leaves, excluding boundary particles
  ntwig = 1
  nleaf = 0


  do while ( nlist > 0 )              ! While any particle not finished:

     level = level + 1                ! Next sublevel

     if (level>nlev) then
       write(*,*) 'Problem with tree on PE ',me,' - no more levels '
       write(*,'(a/(i8,o30))') 'Remaining keys: ',(local_plist(i),local_key(i),i=1,nlist)
       call MPI_ABORT(MPI_COMM_WORLD, 1, ierr)
       stop
     endif

     ibit = nlev - level               ! bit shift factor (0=highest leaf node, nlev-1 = root)
     newleaf=0                         ! # new leaves at this level
     nbound=0                          ! # boundary particles located (max 2)

     ! Determine subcell # from key
     ! At a given level, these will be unique   
     do i=1,nlist
        subcell(i) = ishft( local_key(i), -3_8*ibit )    
        cell_addr(i) = int(IAND( subcell(i), hashconst))         ! cell address hash function
     end do

     if (build_debug) then
        write (ipefile,'(/a//a,i5,a5,i5,a5,z20/)') '---------------','Starting level ',level, &
             ' ibit',ibit,' iplace',iplace
        write (ipefile,*) 'i,   p,     key,           owner     cell_key,    cell_addr'
        write (ipefile,'(2i4,z20,i3,o20,i6)') &
             (i,local_plist(i),local_key(i),local_owner(i),subcell(i),cell_addr(i),i=1,nlist) 
     endif

     nres =0          ! # resolved entries
     ncoll = 0

     !  Make set of entries at current level and tag collisions
     do i = 1,nlist
        if ( htable( cell_addr(i) )%node == 0 .and. htable(cell_addr(i))%key /= -1 ) then       ! Is entry empty?
           nres = nres + 1
           newentry(nres) = cell_addr(i)                  ! Yes, so create new entry:
           htable(cell_addr(i))%node = i                  !   local pointer
           htable(cell_addr(i))%key = subcell(i)          !   key
           htable(cell_addr(i))%leaves = 1                !   # children
           htable(cell_addr(i))%owner = local_owner(i)    ! Set owner of node equal to owner of particle

        else if ( htable( cell_addr(i) )%node /= 0 .AND. &   ! Entry exists and keys match
             htable(cell_addr(i))%key == subcell(i) ) then   ! => twig cell  

           htable(cell_addr(i))%node = i               ! Overwrite previous (leaf) entry
           htable(cell_addr(i))%leaves =  htable(cell_addr(i))%leaves + 1
           htable(cell_addr(i))%owner = me             ! Set owner of node equal to local PE

        else                                    ! Entry exists and keys do not match
           ncoll = ncoll + 1                    ! Increment collision count
           res_addr(ncoll) = cell_addr(i)       ! Reduced list of addresses 
           res_key(ncoll) = subcell(i)          !     ..    .. of keys
           res_node(ncoll) = i                  !     ..    .. of pointers
           res_child(ncoll) =1
           res_owner(ncoll) =local_owner(i)
        end if
     end do

     ! Make reduced list of empty addresses to speed up collision resolution
     i2 = maxaddress  ! count back from end of table
     do i=1,ncoll
        i1 = i2
        do while (htable(i1)%node /= 0 .or. htable(i1)%key==-1 ) 
           i1=i1-1  ! skip existing or dummy entries
        end do
        free_addr(i) = i1
        i2 = i1-1
     end do

     if (build_debug) &
          write(ipefile,*) '# collisions ',ncoll,' free addresses: ',(free_addr(i),i=1,ncoll)

     do i = 1,ncoll

        if ( htable( res_addr(i) )%link == -1) then     ! Entry occupied without link

           nres = nres + 1                             ! create entry at empty address
           newentry(nres) = free_addr(i)                 

           htable( free_addr(i) )%node = res_node(i)                     
           htable( free_addr(i) )%key = res_key(i)
           htable( free_addr(i) )%leaves = res_child(i)
           htable( free_addr(i) )%owner = res_owner(i)
           htable( free_addr(i) )%link = -1
           htable( res_addr(i) )%link = free_addr(i)     ! Create link from 1st duplicate entry to new entry

           ! need to check here for colliding twig nodes

        else if ( htable( res_addr(i) )%link /= -1 ) then     ! Occupied with link already

           link_addr = res_addr(i)                            ! Start of chain
           resolved = .false.                                 ! Resolve flag

           do while ( .not. resolved )       ! Find end of chain  
              link_addr = htable(link_addr)%link

              if ( htable( link_addr )%key == res_key(i) ) then
                 ! Occupied with same key -> twig node
                 htable( link_addr )%leaves =  htable( link_addr )%leaves + 1
                 resolved = .true.
              else if ( htable (link_addr)%link == -1 ) then
                 nres = nres + 1                             ! create entry at empty address
                 newentry(nres) = free_addr(i)
                 htable( free_addr(i) )%node = res_node(i)                     
                 htable( free_addr(i) )%key = res_key(i)
                 htable( free_addr(i) )%leaves = res_child(i)
                 htable( free_addr(i) )%owner = res_owner(i)
                 htable( free_addr(i) )%link = -1                
                 htable( link_addr )%link = free_addr(i)      ! Create link from last duplicate entry to displaced entry
                 resolved = .true.
              else
                 ! not yet resolved
              endif
           end do

        else
           write (ipefile,*) 'Key number ',i,' not resolved'
           call MPI_ABORT(MPI_COMM_WORLD, 1, ierr)
           stop           
        end if
     end do

     ! Go through new entries and sort them into twigs/leaves
     do i = 1,nres

        if ( htable( newentry(i) )%leaves == 1 .and. htable(newentry(i))%owner == me) then
           ! create new leaf
           newleaf = newleaf + 1 
           nleaf = nleaf + 1 
           ipoint =  htable( newentry(i) )%node                  ! local pointer
           htable( newentry(i) )%leaves = 1                      ! contained leaves
           htable( newentry(i) )%childcode = particles(local_ind(ipoint))%label ! store label in #-table
           htable( newentry(i) )%node = local_ind(ipoint)        ! store index in #-table
           htable( newentry(i) )%owner = me                      ! Set owner
           local_plist( ipoint ) = 0                             ! label as done
           treekey(nleaf) = htable(newentry(i))%key              ! Add to key list
 
        else if ( htable( newentry(i) )%leaves == 1 .and. htable(newentry(i))%owner /= me) then
           ! unwanted leaf generated by boundary particle, so remove entry
           ! -> this prevents duplicate branch nodes being generated in make_branches
           nbound = nbound + 1
           ipoint =  htable( newentry(i) )%node         ! local pointer
           local_plist( ipoint ) = 0                    ! label as done - removes particle from list
           htable( newentry(i) )%node = 0               ! remove node from #table
           htable( newentry(i) )%key = -1_8             ! but retain %link to dummy entry 
                                                        ! in case it is in the middle of a chain
           htable( newentry(i) )%leaves = 0
           htable( newentry(i) )%childcode = 0 
        else if ( htable( newentry(i) )%leaves > 1 ) then
           ! twig
           twig_key(ntwig) = htable(newentry(i))%key	         ! Add to key list
           ntwig = ntwig + 1
           htable( newentry(i) )%node = -ntwig
           htable( newentry(i) )%owner = me                       ! Set owner
           htable( newentry(i) )%childcode = 0  ! Zero children byte-code in twig nodes
        else
           write (ipefile,*) 'Problem with flagging'
           call MPI_ABORT(MPI_COMM_WORLD, 1, ierr)
           stop           
        endif

     end do

     ! Make new lists from unfinished particles.

     k=0
     do i=1,nlist
     	if (.not. (local_plist(i)==0)) then
	      k=k+1
          local_key(k) = local_key(i)
          local_ind(k) = local_ind(i)
	      local_plist(k) = local_plist(i)
	      local_owner(k) = local_owner(i)
	    endif
     end do
     
     nlist = nlist - newleaf - nbound

     if (build_debug) then
        !  Go through list of unresolved entries
        write (ipefile,*) 'So far: ',nleaf,' leaves, ',newleaf, 'new on level,',ntwig,' twigs, ',ncoll,' collisions'
        write (ipefile,*) 'Particles left: ',nlist,', new list:',local_plist(1:nlist)
     endif

  end do

  call timer_stop(t_build_pure)

  deallocate(subcell,cell_addr)

  call timer_stop(t_build_part)
  call timer_start(t_build_byte)

  nnodes = nleaf + ntwig  ! total number of local tree nodes

  if (nleaf .ne. npp) then
    write(*,*) me, nleaf, npp
    stop
  endif

  twig_key(ntwig) = 1  ! add root for later
  treekey(nleaf+1:nnodes) = twig_key(1:ntwig)  ! add twigs to list 
  nsubset=0

  do i=1,nnodes-1
     childbyte = int(IAND( treekey(i), hashchild))    ! extract last 3 bits from key
     parent_key = ishft( treekey(i),-3 )      ! parent key
     parent_addr = key2addr(parent_key,'BUILD: childbyte')
     ! Construct children byte-code (8 settable bits indicating which children nodes present)
     htable(parent_addr)%childcode = ibset( htable(parent_addr)%childcode, childbyte )
     treelevel  = level_from_key(treekey(i))     ! node levels
     if (treelevel==1) then
        nsubset = nsubset+1  ! # nodes at level 1
        search_key(nsubset) = treekey(i)   ! Subset of nodes at same level
     endif
  end do
  treelevel  = level_from_key(treekey(nnodes))     ! node levels
  if (treelevel==1) then
     nsubset = nsubset+1  ! # nodes at level 1
     search_key(nsubset) = treekey(nnodes)   ! Subset of nodes at same level
  endif

  sum_unused = 0
  iused = 1   ! reset used-address counter
  do i=0, maxaddress
     if (htable(i)%node == 0 .and. htable(i)%key /=-1 .and. i> free_lo) then
        sum_unused = sum_unused+1
        free_addr(sum_unused) = i            ! Free address list for resolving collisions
        point_free(i) = sum_unused           ! Index
     else
        point_free(i) = 0
     endif
  enddo

  call timer_stop(t_build_byte)
  call timer_stop(t_build)

!!! --------------- TREE BRANCHES (local part) ---------------

  call timer_start(t_branches_find)
  
  nleaf_me = nleaf       !  Retain leaves and twigs belonging to local PE
  ntwig_me = ntwig
  if (tree_debug .and. (proc_debug==me .or.proc_debug==-1)) call check_table('after treebuild     ')

  call find_branches(branch_level_D1, branch_level_D2)

  if (tree_debug .and. (proc_debug==me .or.proc_debug==-1)) call check_table('after local branches     ')

  call timer_stop(t_branches_find)


!!! --------------- TREE PROPERTIES (local part) ---------------


  call timer_start(t_props_leafs)

  !  Start with *local* leaf properties
  do i=1, nleaf_me
     addr_leaf = key2addr( treekey(i),'PROPERTIES: local' )   !  Table address
     p_leaf = htable( addr_leaf )%node   !  Local particle index  - points to properties on PE
     htable(addr_leaf)%childcode = IBSET( htable(addr_leaf)%childcode, CHILDCODE_NODE_TOUCHED ) ! I have touched this node, do not zero its properties (in tree_global)
     node_leaf = p_leaf   !  Leaf node index is identical to particle index for *local* leaves

     call multipole_from_particle(particles( p_leaf ), tree_nodes( node_leaf ) )

  end do

  call timer_stop(t_props_leafs)
  call timer_start(t_props_twigs)

  !  Accumulate local twig properties
  !  Make list of twig nodes contained within local branch list (pebranch).  Recursive search adapted from make_branches.

  search_key(1:nbranch) = pebranch(1:nbranch)            ! start with branch list
  ncheck = 0       ! Checksum
  newsub = 0
  ntwig_domain = 0  ! # twigs contained in branch list
  nsearch = nbranch
  res_key = 0

  do while ( ncheck < nleaf_me )     ! Repeat until all local leaves found

     do i=1,nsearch
        if (  htable( key2addr( search_key(i),'PROPERTIES: twigs' ) )%node > 0 ) then
           !  leaf,  so skip and increment checksum
           ncheck = ncheck +  1  

        else 
           ! twig: add to list and  subdivide
           ntwig_domain = ntwig_domain + 1
           res_key(ntwig_domain) = search_key(i)

           cchild = htable( key2addr( search_key(i),'PROPERTIES: tw2' ) )%childcode   !  Children byte-code
           nchild = SUM( (/ (ibits(cchild,j,1),j=0,7) /) ) ! # children = sum of bits in byte-code
           sub_key(1:nchild) = pack( bitarr, mask=(/ (btest(cchild,j),j=0,7) /) )  ! Extract child sub-keys from byte code

           resolve_key(newsub+1:newsub+nchild) = IOR( ishft( search_key(i),3 ), sub_key(1:nchild) ) ! Add keys of children to new search list
           newsub = newsub + nchild

        endif
     end do

     search_key(1:newsub) = resolve_key(1:newsub)        ! Put children into search list
     nsearch = newsub  ! # new nodes to search
     newsub = 0
  end do

  call sort(res_key(1:ntwig_domain))
  
  if (props_debug) then
     write (ipefile,*) '# Twigs contained in local branch list: ',ntwig_domain
     write (ipefile,*) 'Found ',ncheck,' out of ',nleaf,' leaves'
  endif

  do i=1,ntwig_domain
     addr_twig = key2addr( res_key(i),'PROPERTIES: domain' )   !  Table address
     res_node(i) = htable( addr_twig )%node   !  Twig node index  
     res_child(i) = htable( addr_twig )%childcode   !  Twig children byte-code 
     htable(addr_twig)%childcode = IBSET( htable(addr_twig)%childcode, CHILDCODE_NODE_TOUCHED ) ! I have touched this node, do not zero its properties (in tree_global)
  end do  

  ! Go up through tree, starting at deepest level (largest key first)
  ! and accumulate multipole moments onto twig nodes
  do i = ntwig_domain,1,-1
     res=>tree_nodes(res_node(i))

         nchild = SUM( (/ (ibits(res_child(i),j,1),j=0,7) /) )                 ! Get # children
         sub_key(1:nchild) = pack( bitarr, mask=(/ (btest(res_child(i),j),j=0,7) /) )  ! Extract sub key from byte code

         do j=1,nchild
            key_child(j) = IOR( ishft( res_key(i),3 ), sub_key(j) )      ! Construct keys of children
            addr_child = key2addr( key_child(j),'PROPERTIES: domain2' )             ! Table address of children
            node_child(j) = htable( addr_child )%node                     ! Child node index
         end do

         call shift_nodes_up(res, tree_nodes(node_child(1:nchild)))

  end do

  ! Should now have multipole information up to branch list level(s).
  ! By definition, this is complete: each branch node is self-contained.
  ! This information has to be broadcast to the other PEs so that the top levels can be filled in.

  call timer_stop(t_props_twigs)
  call timer_stop(t_local)

end subroutine tree_local







