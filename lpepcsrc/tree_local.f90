!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!>
!> Build the local tree structure, then find local branches,
!> after that compute properties up to branch level.
!>
!> The tree will be refined until every particle owns a cell
!> that contains no other particle. By this step additional cells
!> were introduced. (TODO: local fill nodes on the fly => global merge).
!> Level by level for every cell it will be differentiate between
!> twigs and leafs (node). Finally, for fast children computaion,
!> the childbyte will be updated.
!>
!> Possible branch candidates are generated by the branch-estimation.
!> If the candidate exists, it will added to the branch list.
!>
!> The branches are on different levels. For every branch the properties
!> are calculated.
!>
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine tree_local

  use treevars
  use timings
  use tree_utils
  use module_branching
  use module_htable
  use module_spacefilling
  use module_interaction_specific
  use module_tree

  implicit none
  include 'mpif.h'

  integer :: i, k, i1, i2, ierr, level_match, level_diff, ibit, iend, level, nbound, newleaf, nres, ncoll, &
       link_addr, ipoint, addr_leaf, p_leaf, node_leaf
  integer*8 ::  key_lo, cell1, cell2
  integer*8 :: leaf_key(maxleaf)       ! keys of all twig and leaf nodes

  logical :: resolved

  integer*8, dimension(nppm+2) :: local_key
  integer, dimension(nppm+2)  :: local_plist, local_owner, local_ind
  integer*8, allocatable :: subcell(:)
  integer, allocatable :: cell_addr(:)
  integer*8, dimension(maxaddress) :: res_key
  integer, dimension(maxaddress) :: newentry, res_addr, res_node, res_child, res_owner

!!! --------------- TREE BUILD ---------------

 
  call timer_start(t_local)
  call timer_start(t_build)
  call timer_start(t_build_neigh)

  if (tree_debug) write(ipefile,'(/a)') 'TREE LOCAL'
  if (me==0 .and. tree_debug) write(*,'(a)') 'LPEPC | LOCAL BUILD'

  call htable_clear()

  do i=1,npp+2
     local_plist(i) = particles(i)%label       ! Particle (global) label for tracking purposes
     if (local_plist(i) == 0) local_plist(i) = huge(local_plist(i))
     local_key(i)   = particles(i)%key           ! Particle key
     local_owner(i) = particles(i)%pid
  end do
  i=0                     ! List of free (unused #table-addresses) 

  !  Check whether boundary particles are close enough to warrant inclusion
  !  in tree construction.
  
  nlist = npp

  ! RH neighbour PE 
  if ( me /= num_pe-1 ) then
     ! First find level shared by last particle pair in list
     key_lo = ieor( particles(npp)%key, particles(npp-1)%key )   ! Picks out 1st position where keys differ
     level_diff =  level_from_key(key_lo)
     level_match = max( nlev - level_diff, 1 )    ! Excludes low-level end-cells for discontinuous domains
     ibit = nlev-level_match               ! bit shift factor 

     cell1 = ishft( particles(npp  )%key, -3*ibit )    ! Subcell number of RH boundary particle
     cell2 = ishft( particles(npp+1)%key, -3*ibit )    ! Subcell number of LH boundary particle of neighbouring PE
     if (cell1 == cell2) then
        nlist = nlist+1                    ! If keys match at this level then include boundary particle in local tree
        local_plist(nlist) = particles(npp+1)%label
        local_key(nlist)   = particles(npp+1)%key
        local_owner(nlist) = me+1
        if (build_debug) write (ipefile,'(a,i5,a)') 'boundary particle from PE',me+1,' included in list'
     endif

  endif

  ! 2nd set: LH neighbour PE
  if ( me /= 0 ) then
     iend = npp+2
     if ( me == num_pe-1 ) iend = npp+1         ! End node only has one boundary particle
     ! First find level shared by first particle pair in list
     key_lo = ieor( particles(1)%key, particles(2)%key  )   ! Picks out lower order bits where keys differ
     level_diff =  level_from_key(key_lo)

     level_match = max( nlev - level_diff, 1 )    ! Excludes low-level end-cells for discontinuous domains
     ibit = nlev-level_match               ! bit shift factor 

     cell1 = ishft( particles(   1)%key, -3*ibit )    ! Subcell number of LH boundary particle
     cell2 = ishft( particles(iend)%key, -3*ibit )    ! Subcell number of RH boundary particle of neighbouring PE
     if (cell1 == cell2) then
        nlist = nlist+1         ! If keys match at this level then include boundary particle in local tree
        local_plist(nlist) = particles(iend)%label
        local_key(nlist)   = particles(iend)%key
        local_owner(nlist) = me-1
        if (build_debug) write (ipefile,'(a,i5,a)') 'boundary particle from PE',me-1,' included in list'
     endif
  endif

  call timer_stop(t_build_neigh)
  call timer_start(t_build_part)

  allocate(subcell(1:nlist),cell_addr(1:nlist))

  call timer_start(t_build_pure)

  level = 0                        ! start at root
  local_ind(1:nlist) = (/(k,k=1,nlist)/) ! Sorted local particle index / leaf number: points to particle properties

  !  set up root node

  htable(1)%node   =  -1              !  node #
  htable(1)%owner  =  me              ! Owner
  htable(1)%key    =   1_8            !  key
  htable(1)%link   =  -1              !  collision link
  htable(1)%leaves = 0                ! root contains all leaves, excluding boundary particles - we will check this after tree buildup
  htable(1)%childcode = IBSET(0, CHILDCODE_BIT_CHILDREN_AVAILABLE)
  ntwig = 1
  nleaf = 0


  do while ( nlist > 0 )              ! While any particle not finished:

     level = level + 1                ! Next sublevel

     if (level>nlev) then
       write(*,*) 'Problem with tree on PE ',me,' - no more levels '
       write(*,'(a/(i8,o30))') 'Remaining keys: ',(local_plist(i),local_key(i),i=1,nlist)
       call MPI_ABORT(MPI_COMM_WORLD, 1, ierr)
       stop
     endif

     ibit = nlev - level               ! bit shift factor (0=highest leaf node, nlev-1 = root)
     newleaf=0                         ! # new leaves at this level
     nbound=0                          ! # boundary particles located (max 2)

     ! Determine subcell # from key
     ! At a given level, these will be unique   
     do i=1,nlist
        subcell(i) = ishft( local_key(i), -3_8*ibit )    
        cell_addr(i) = int(IAND( subcell(i), hashconst))         ! cell address hash function
     end do

     if (build_debug) then
        write (ipefile,'(/a//a,i5,a5,i5,a5,z20/)') '---------------','Starting level ',level, &
             ' ibit',ibit,' iplace',iplace
        write (ipefile,*) 'i,   p,     key,           owner     cell_key,    cell_addr'
        write (ipefile,'(2i4,z20,i3,o20,i6)') &
             (i,local_plist(i),local_key(i),local_owner(i),subcell(i),cell_addr(i),i=1,nlist) 
     endif

     nres =0          ! # resolved entries
     ncoll = 0

     !  Make set of entries at current level and tag collisions
     do i = 1,nlist
        if ( htable( cell_addr(i) )%node == 0 .and. htable(cell_addr(i))%key /= -1 ) then       ! Is entry empty?
           nres = nres + 1
           newentry(nres) = cell_addr(i)                  ! Yes, so create new entry:
           htable(cell_addr(i))%node = i                  !   local pointer
           htable(cell_addr(i))%key = subcell(i)          !   key
           htable(cell_addr(i))%leaves = 1                !   # children
           htable(cell_addr(i))%owner = local_owner(i)    ! Set owner of node equal to owner of particle

        else if ( htable( cell_addr(i) )%node /= 0 .AND. &   ! Entry exists and keys match
             htable(cell_addr(i))%key == subcell(i) ) then   ! => twig cell  

           htable(cell_addr(i))%node = i               ! Overwrite previous (leaf) entry
           htable(cell_addr(i))%leaves =  htable(cell_addr(i))%leaves + 1
           htable(cell_addr(i))%owner = me             ! Set owner of node equal to local PE

        else                                    ! Entry exists and keys do not match
           ncoll = ncoll + 1                    ! Increment collision count
           res_addr(ncoll) = cell_addr(i)       ! Reduced list of addresses 
           res_key(ncoll) = subcell(i)          !     ..    .. of keys
           res_node(ncoll) = i                  !     ..    .. of pointers
           res_child(ncoll) =1
           res_owner(ncoll) =local_owner(i)
        end if
     end do

     ! Make reduced list of empty addresses to speed up collision resolution
     i2 = maxaddress  ! count back from end of table
     do i=1,ncoll
        i1 = i2
        do while (htable(i1)%node /= 0 .or. htable(i1)%key==-1 ) 
           i1=i1-1  ! skip existing or dummy entries
        end do
        free_addr(i) = i1
        i2 = i1-1
     end do

     if (build_debug) &
          write(ipefile,*) '# collisions ',ncoll,' free addresses: ',(free_addr(i),i=1,ncoll)

     do i = 1,ncoll

        if ( htable( res_addr(i) )%link == -1) then     ! Entry occupied without link

           nres = nres + 1                             ! create entry at empty address
           newentry(nres) = free_addr(i)                 

           htable( free_addr(i) )%node = res_node(i)                     
           htable( free_addr(i) )%key = res_key(i)
           htable( free_addr(i) )%leaves = res_child(i)
           htable( free_addr(i) )%owner = res_owner(i)
           htable( free_addr(i) )%link = -1
           htable( res_addr(i) )%link = free_addr(i)     ! Create link from 1st duplicate entry to new entry

           ! need to check here for colliding twig nodes

        else if ( htable( res_addr(i) )%link /= -1 ) then     ! Occupied with link already

           link_addr = res_addr(i)                            ! Start of chain
           resolved = .false.                                 ! Resolve flag

           do while ( .not. resolved )       ! Find end of chain  
              link_addr = htable(link_addr)%link

              if ( htable( link_addr )%key == res_key(i) ) then
                 ! Occupied with same key -> twig node
                 htable( link_addr )%leaves =  htable( link_addr )%leaves + 1
                 resolved = .true.
              else if ( htable (link_addr)%link == -1 ) then
                 nres = nres + 1                             ! create entry at empty address
                 newentry(nres) = free_addr(i)
                 htable( free_addr(i) )%node = res_node(i)                     
                 htable( free_addr(i) )%key = res_key(i)
                 htable( free_addr(i) )%leaves = res_child(i)
                 htable( free_addr(i) )%owner = res_owner(i)
                 htable( free_addr(i) )%link = -1                
                 htable( link_addr )%link = free_addr(i)      ! Create link from last duplicate entry to displaced entry
                 resolved = .true.
              else
                 ! not yet resolved
              endif
           end do

        else
           write (ipefile,*) 'Key number ',i,' not resolved'
           call MPI_ABORT(MPI_COMM_WORLD, 1, ierr)
           stop           
        end if
     end do

     ! Go through new entries and sort them into twigs/leaves
     do i = 1,nres

        if ( htable( newentry(i) )%leaves == 1 .and. htable(newentry(i))%owner == me) then
           ! create new leaf
           newleaf = newleaf + 1 
           nleaf = nleaf + 1 
           ipoint =  htable( newentry(i) )%node                  ! local pointer
           htable( newentry(i) )%leaves = 1                      ! contained leaves
           htable( newentry(i) )%childcode = particles(local_ind(ipoint))%label ! store label in #-table
           htable( newentry(i) )%node = local_ind(ipoint)        ! store index in #-table
           htable( newentry(i) )%owner = me                      ! Set owner
           local_plist( ipoint ) = 0                             ! label as done
           leaf_key(nleaf) = htable(newentry(i))%key              ! Add to key list
 
        else if ( htable( newentry(i) )%leaves == 1 .and. htable(newentry(i))%owner /= me) then
           ! unwanted leaf generated by boundary particle, so remove entry
           ! -> this prevents duplicate branch nodes being generated in make_branches
           nbound = nbound + 1
           ipoint =  htable( newentry(i) )%node         ! local pointer
           local_plist( ipoint ) = 0                    ! label as done - removes particle from list
           htable( newentry(i) )%node = 0               ! remove node from #table
           htable( newentry(i) )%key = -1_8             ! but retain %link to dummy entry 
                                                        ! in case it is in the middle of a chain
           htable( newentry(i) )%leaves = 0
           htable( newentry(i) )%childcode = 0 
        else if ( htable( newentry(i) )%leaves > 1 ) then
           ! twig
           ntwig = ntwig + 1
           htable( newentry(i) )%node = -ntwig
           htable( newentry(i) )%owner = me                       ! Set owner
           htable( newentry(i) )%childcode = IBSET( 0, CHILDCODE_BIT_CHILDREN_AVAILABLE )   ! Set children_HERE flag for all local twig nodes
           !htable( newentry(i) )%childcode = 0
        else
           write (ipefile,*) 'Problem with flagging'
           call MPI_ABORT(MPI_COMM_WORLD, 1, ierr)
           stop           
        endif

     end do

     ! Make new lists from unfinished particles.

     k=0
     do i=1,nlist
     	if (.not. (local_plist(i)==0)) then
	      k=k+1
          local_key(k) = local_key(i)
          local_ind(k) = local_ind(i)
	      local_plist(k) = local_plist(i)
	      local_owner(k) = local_owner(i)
	    endif
     end do
     
     nlist = nlist - newleaf - nbound

     if (nlist.ne.k) then
       write(*,*) 'PE', me, ': error in bookkeeping in local tree buildup'
       call MPI_ABORT(MPI_COMM_WORLD, 1, ierr)
     endif

     if (build_debug) then
        !  Go through list of unresolved entries
        write (ipefile,*) 'So far: ',nleaf,' leaves, ',newleaf, 'new on level,',ntwig,' twigs, ',ncoll,' collisions'
        write (ipefile,*) 'Particles left: ',nlist,', new list:',local_plist(1:nlist)
     endif

  end do

  call timer_stop(t_build_pure)

  deallocate(subcell,cell_addr)

  call timer_stop(t_build_part)
  call timer_start(t_build_byte)

  if (nleaf .ne. npp) then
    write(*,*) 'PE', me, ' has', npp, ' local particles, but created', nleaf, ' leave nodes'
    call MPI_ABORT(MPI_COMM_WORLD, 1, ierr)
  endif

  ! rebuild list of free addresses for faster collision resolution on insertion into htable
  sum_unused = 0
  iused = 1   ! reset used-address counter
  do i=0, maxaddress
     if (htable(i)%node == 0 .and. htable(i)%key /=-1 .and. i> free_lo) then
        sum_unused = sum_unused+1
        free_addr(sum_unused) = i            ! Free address list for resolving collisions
        point_free(i) = sum_unused           ! Index
     else
        point_free(i) = 0
     endif
  enddo

  call timer_stop(t_build_byte)
  call timer_stop(t_build)

  nleaf_me = nleaf       !  Retain leaves and twigs belonging to local PE
  ntwig_me = ntwig
  if (tree_debug .and. (proc_debug==me .or. proc_debug==-1)) call check_table('after treebuild     ')

!!! --------------- TREE PROPERTIES (local part) ---------------


  call timer_start(t_props_leafs)

  !  Start with *local* leaf properties
  do i=1, nleaf_me
     addr_leaf = key2addr( leaf_key(i),'PROPERTIES: local' )   !  Table address
     p_leaf    = htable( addr_leaf )%node   !  Local particle index  - points to properties on PE
     htable(addr_leaf)%childcode = 0 ! leaves do not have any children, special flags are also not needed
     node_leaf = p_leaf   !  Leaf node index is identical to particle index for *local* leaves

     call multipole_from_particle(particles( p_leaf )%x, particles( p_leaf )%data, tree_nodes( node_leaf ) )

  end do

  call timer_stop(t_props_leafs)
  call timer_start(t_props_twigs)
  
  ! build tree from local particle keys up to root
  ! TODO: * group leaf_keys branchwise (using is_parent_of() and keys from pebranch)
  !       * restrict tree_build_upwards to only run to a certain level
  !       * call it several times with keylists and branch_levels
  call tree_build_upwards(leaf_key(1:nleaf_me), nleaf_me)

  ! Should now have multipole information up to branch list level(s).
  ! By definition, this is complete: each branch node is self-contained.
  ! This information has to be broadcast to the other PEs so that the top levels can be filled in.

  call timer_stop(t_props_twigs)

!!! --------------- TREE BRANCHES (local part) ---------------

  call timer_start(t_branches_find)
  call find_branches(branch_level_D1, branch_level_D2)
  call timer_stop(t_branches_find)

  if (tree_debug .and. (proc_debug==me .or. proc_debug==-1)) call check_table('after local branches     ')

  call timer_stop(t_local)

end subroutine tree_local
