<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PEPC: tree_aswalk.f90 Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7-20060810 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Packages</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir_75b82e7e4a5feb05200b9ad7adf06257.html">home</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_28272fc65e3d756317163f9acb2ad644.html">gibbon</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_e3e416c1e3f7ebc92335d37fb0dd4777.html">pepc</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_445afc100a243ec0eaed19e4a2dc673c.html">lpepcsrc</a></div>
<h1>tree_aswalk.f90</h1><a href="tree__aswalk_8f90.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 ! ===========================================
<a name="l00002"></a>00002 !
<a name="l00003"></a>00003 !           TREE_WALK
<a name="l00004"></a>00004 !
<a name="l00005"></a>00005 !   $ Revision: 1.19 $
<a name="l00006"></a>00006 !
<a name="l00007"></a>00007 !   Perform tree walk <span class="keywordflow">for</span> all local particles
<a name="l00008"></a>00008 !
<a name="l00009"></a>00009 !  Algorithm follows Warren &amp; Salmon's 'latency-hiding' concept,
<a name="l00010"></a>00010 !  retaining list-based tree-walk from vectorised code by Pfalzner &amp; Gibbon.
<a name="l00011"></a>00011 !
<a name="l00012"></a>00012 !  Structure:
<a name="l00013"></a>00013 !
<a name="l00014"></a>00014 !    <span class="keywordflow">while</span> (any particle still active) <span class="keywordflow">do</span>
<a name="l00015"></a>00015 !
<a name="l00016"></a>00016 !      <span class="keywordflow">while</span> (any particle not finished walk) <span class="keywordflow">do</span>
<a name="l00017"></a>00017 !
<a name="l00018"></a>00018 !         <span class="keywordflow">if</span> (MAC OK) 
<a name="l00019"></a>00019 !            put node on interaction list
<a name="l00020"></a>00020 !         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (MAC not OK and local)
<a name="l00021"></a>00021 !            resolve node
<a name="l00022"></a>00022 !         <span class="keywordflow">else</span> 
<a name="l00023"></a>00023 !            put node on defer list
<a name="l00024"></a>00024 !         endif
<a name="l00025"></a>00025 !
<a name="l00026"></a>00026 !      end <span class="keywordflow">while</span>
<a name="l00027"></a>00027 !      
<a name="l00028"></a>00028 !      process requests <span class="keywordflow">for</span> non-local nodes
<a name="l00029"></a>00029 !      insert <span class="keyword">new</span> children into local tree (<a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>)
<a name="l00030"></a>00030 !      copy defer list -&gt; <span class="keyword">new</span> walk list
<a name="l00031"></a>00031 !      count remaining active particles
<a name="l00032"></a>00032 !
<a name="l00033"></a>00033 !    end <span class="keywordflow">while</span>
<a name="l00034"></a>00034 !
<a name="l00035"></a>00035 ! ===========================================
<a name="l00036"></a>00036 
<a name="l00037"></a><a class="code" href="tree__aswalk_8f90.html#edc62302e0a6458cc8830d1d676dd759">00037</a> subroutine <a class="code" href="tree__aswalk_8f90.html#edc62302e0a6458cc8830d1d676dd759">tree_walk</a>(pshort,npshort, pass,<a class="code" href="namelist_8h.html#2debd5e81fbe9e3985b18628f622d180">theta</a>,<a class="code" href="namelist_8h.html#3d5b0f2d79621403cfab74bce3469eb1">eps</a>,<a class="code" href="namespacephysvars.html#c125a4e0d163ae9c82706249ee8ddee4">itime</a>,<a class="code" href="namelist_8h.html#051ba9b635fca70611c05a5b65e92cd1">mac</a>,twalk,tfetch)
<a name="l00038"></a>00038 
<a name="l00039"></a>00039   use treevars
<a name="l00040"></a>00040   use tree_utils
<a name="l00041"></a>00041   use utils
<a name="l00042"></a>00042   implicit none
<a name="l00043"></a>00043   include 'mpif.h'
<a name="l00044"></a>00044 
<a name="l00045"></a>00045   real, intent(in) :: <a class="code" href="namelist_8h.html#2debd5e81fbe9e3985b18628f622d180">theta</a>, <a class="code" href="namelist_8h.html#3d5b0f2d79621403cfab74bce3469eb1">eps</a>
<a name="l00046"></a>00046   integer, intent(in) :: npshort,<a class="code" href="namespacephysvars.html#c125a4e0d163ae9c82706249ee8ddee4">itime</a>
<a name="l00047"></a>00047   integer, intent(in) :: pshort(npshort)
<a name="l00048"></a>00048   integer, intent(in) :: <a class="code" href="namelist_8h.html#051ba9b635fca70611c05a5b65e92cd1">mac</a>
<a name="l00049"></a>00049   ! integer, intent(out) :: <a class="code" href="namespacetreevars.html#038c4e890b46de1d1dce97658d24652c">nodelist</a>(nintm, npshort)
<a name="l00050"></a>00050   integer :: npackm   ! Max <span class="preprocessor"># children shipped</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>  integer :: nchild_shipm
<a name="l00052"></a>00052   real :: twalk, tfetch, tw1, tw2, tc1, tf1, tf2
<a name="l00053"></a>00053 
<a name="l00054"></a>00054   ! Key arrays (64-bit)
<a name="l00055"></a>00055 
<a name="l00056"></a>00056   integer*8,  dimension(npshort) :: walk_key, walk_last 
<a name="l00057"></a>00057   integer*8, dimension(<a class="code" href="namespacetreevars.html#88ddb99cee17ffd203ed6e3adbdebaa5">maxaddress</a>)  :: request_key, ask_key, process_key
<a name="l00058"></a>00058   integer*8, dimension(<a class="code" href="namespacetreevars.html#e34bba8fd21d4150370b72505a8b8ab7">size_fetch</a>) ::  ship_keys
<a name="l00059"></a>00059   integer*8, dimension(8) :: sub_key, key_child, next_child
<a name="l00060"></a>00060   integer*8, dimension(<a class="code" href="namespacetreevars.html#4f04c8bb799d1a68b883e63b3746012d">nintmax</a>,npshort) :: defer_list, walk_list
<a name="l00061"></a>00061   integer*8, dimension(<a class="code" href="namespacetreevars.html#88ddb99cee17ffd203ed6e3adbdebaa5">maxaddress</a>) :: last_child   ! List of 'last' children fetched from remote PEs
<a name="l00062"></a>00062 
<a name="l00063"></a>00063   integer, dimension(npshort) :: plist
<a name="l00064"></a>00064 
<a name="l00065"></a>00065   integer ::  walk_addr, walk_node, entry_next 
<a name="l00066"></a>00066   integer, dimension(npshort) :: nlocal, ndefer,  nwalk, defer_ctr
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 
<a name="l00069"></a>00069   integer, dimension(<a class="code" href="namespacetreevars.html#88ddb99cee17ffd203ed6e3adbdebaa5">maxaddress</a>) ::  process_addr, request_owner, reqlist
<a name="l00070"></a>00070   integer, dimension(<a class="code" href="namespacetreevars.html#88ddb99cee17ffd203ed6e3adbdebaa5">maxaddress</a>) :: childbyte
<a name="l00071"></a>00071   integer, dimension(8) :: addr_child, node_child, byte_child, leaves_child
<a name="l00072"></a>00072 
<a name="l00073"></a>00073   real*8, dimension(8) :: xcoc_child, ycoc_child, zcoc_child
<a name="l00074"></a>00074 
<a name="l00075"></a>00075   real, dimension(0:<a class="code" href="namespacetreevars.html#5f5b3f17c0444f500a18ba56caa6fa48">nlev</a>) :: boxlength2
<a name="l00076"></a>00076   logical, dimension(npshort) :: finished, requested
<a name="l00077"></a>00077   integer :: hops(21) ! array to control max <span class="preprocessor"># iterations in single traversal </span>
<a name="l00078"></a>00078 <span class="preprocessor"></span>  integer, dimension(<a class="code" href="namespacetreevars.html#694640a77e3d8236c59add8bfa3c133b">num_pe</a>) ::   nactives
<a name="l00079"></a>00079   integer, dimension(0:<a class="code" href="namespacetreevars.html#694640a77e3d8236c59add8bfa3c133b">num_pe</a>-1) :: nfetches, &amp;              ! # keys needed
<a name="l00080"></a>00080        nrequests, &amp;           ! # keys requested from elsewhere
<a name="l00081"></a>00081        istart, ic_start, &amp;     ! # fenceposts
<a name="l00082"></a>00082        nplace,&amp;                ! # children (new entries) to place in table
<a name="l00083"></a>00083        nchild_ship       ! # children shipped to others
<a name="l00084"></a>00084   integer, dimension(<a class="code" href="namespacetreevars.html#694640a77e3d8236c59add8bfa3c133b">num_pe</a>) :: send_key_handle, recv_key_handle
<a name="l00085"></a>00085   integer, dimension(<a class="code" href="namespacetreevars.html#e34bba8fd21d4150370b72505a8b8ab7">size_fetch</a>) :: send_child_handle, recv_child_handle
<a name="l00086"></a>00086 
<a name="l00087"></a>00087   ! Key working vars
<a name="l00088"></a>00088   integer*8 :: node_key, add_key, walk_next, kchild, kparent, search_key,  nxchild
<a name="l00089"></a>00089 
<a name="l00090"></a>00090   integer :: i, j, k, ic, ipe, iwait, inner_pass, nhops          ! loop counters
<a name="l00091"></a>00091   integer :: p,pass
<a name="l00092"></a>00092   integer :: nnew, nshare, newrequest, nreqs, i1, i2, ioff, ipack
<a name="l00093"></a>00093   integer :: nchild, newleaf, newtwig, nactive, maxactive, ntraversals, own
<a name="l00094"></a>00094   integer :: ic1, ic2, iship1, ihand, nchild_ship_tot, nplace_max, sum_pack
<a name="l00095"></a>00095   integer, save ::  sum_nhops, sum_inner_pass, sum_nhops_old=0, sum_inner_old=0
<a name="l00096"></a>00096   integer :: request_count, fetch_pe_count, send_prop_count  ! buffer counters
<a name="l00097"></a>00097 
<a name="l00098"></a>00098   integer ::  bchild, nodchild, lchild, hashaddr, nlast_child, cbyte
<a name="l00099"></a>00099   integer :: max_nplace, max_pack
<a name="l00100"></a>00100   real :: sbox, theta2, theta2_ion, dx, dy, dz, s2, dist2
<a name="l00101"></a>00101 
<a name="l00102"></a>00102   ! stuff for tree-patch after traversals complete
<a name="l00103"></a>00103   integer ::  node_addr, parent_addr, parent_node, child_byte
<a name="l00104"></a>00104   integer :: jmatch(1)
<a name="l00105"></a>00105   logical :: resolved, keymatch(8), emulate_blocking=.false.
<a name="l00106"></a>00106   logical :: ignore, mac_ok
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   integer :: nrest, ndef
<a name="l00109"></a>00109   integer :: <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a>, nbuf, status(MPI_STATUS_SIZE)
<a name="l00110"></a>00110   integer :: tag1=40
<a name="l00111"></a>00111 
<a name="l00112"></a>00112   integer :: <a class="code" href="get__address_8f90.html#2809b00e2dcb999b654cac13b2ffb261">key2addr</a>        ! Mapping function to get hash table <a class="code" href="namespacetreevars.html#3ecc2e98e400f5751ae1758d72035e15">address</a> from key
<a name="l00113"></a>00113   integer*8 :: <a class="code" href="get__next__node_8f90.html#a175a80527b401074396161119b2d63f">next_node</a>   ! Function to get next node key for local tree walk
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 
<a name="l00116"></a>00116   !
<a name="l00117"></a>00117   twalk=0.
<a name="l00118"></a>00118   tfetch=0.
<a name="l00119"></a>00119 
<a name="l00120"></a>00120   npackm = <a class="code" href="namespacetreevars.html#88ddb99cee17ffd203ed6e3adbdebaa5">maxaddress</a>
<a name="l00121"></a>00121   nchild_shipm = <a class="code" href="namespacetreevars.html#88ddb99cee17ffd203ed6e3adbdebaa5">maxaddress</a>
<a name="l00122"></a>00122   !  <a class="code" href="namespacetreevars.html#415096877a1abe9a37d0435e96d0f30a">walk_debug</a> = .false.
<a name="l00123"></a>00123   ! <a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a> = 6
<a name="l00124"></a>00124   if (<a class="code" href="namespacetreevars.html#415096877a1abe9a37d0435e96d0f30a">walk_debug</a> .or. <a class="code" href="namespacetreevars.html#af03d6c35b13db23cd43b4522df652a4">walk_summary</a>) write(<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,'(/2(a,i6))') '*** TREE WALK (AS) for timestep ',<a class="code" href="namespacephysvars.html#c125a4e0d163ae9c82706249ee8ddee4">itime</a>,' pass ',pass
<a name="l00125"></a>00125   if (<a class="code" href="namespacetreevars.html#f0c1ebe7c983f1b1061d88e367afc933">me</a>.eq.0 .and. <a class="code" href="namespacetreevars.html#af03d6c35b13db23cd43b4522df652a4">walk_summary</a>) write(*,'(2(a,i6))') 'LPEPC | TREE WALK (AS) for timestep ',<a class="code" href="namespacephysvars.html#c125a4e0d163ae9c82706249ee8ddee4">itime</a>,' pass ',pass
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   sbox = <a class="code" href="namespacetreevars.html#8b7d0bfaafb4911e08470411d32719f7">boxsize</a>
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   theta2 = theta**2               ! Clumping parameter**2 for MAC
<a name="l00131"></a>00131   !  theta2_ion = min(1.0,2*theta2)  ! Ion MAC 50% larger than electron MAC
<a name="l00132"></a>00132   theta2_ion=theta2
<a name="l00133"></a>00133   boxlength2(0)=sbox**2
<a name="l00134"></a>00134   do i=1,<a class="code" href="namespacetreevars.html#5f5b3f17c0444f500a18ba56caa6fa48">nlev</a>
<a name="l00135"></a>00135      boxlength2(i) =  boxlength2(i-1)/4.  ! Preprocessed box sizes for each level
<a name="l00136"></a>00136   end do
<a name="l00137"></a>00137 
<a name="l00138"></a>00138   walk_key(1:npshort) = 1                    ! initial walk list starts at root
<a name="l00139"></a>00139   nwalk(1:npshort) = 0   ! # keys on deferred list
<a name="l00140"></a>00140   defer_ctr(1:npshort) = 1   ! Deferral counter
<a name="l00141"></a>00141   <a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a> = npshort                 ! Inner loop list length
<a name="l00142"></a>00142   plist(1:npshort) = (/ (i,i=1,npshort) /)       ! initial local particle indices 
<a name="l00143"></a>00143   <a class="code" href="namespacetreevars.html#0c00c9ba3fcb9b5b155b47f4a1df1011">nterm</a>(1:npshort) = 0
<a name="l00144"></a>00144   nactive = npshort
<a name="l00145"></a>00145 
<a name="l00146"></a>00146   !  Find global max active particles - necessary if some PEs enter walk on dummy pass
<a name="l00147"></a>00147 
<a name="l00148"></a>00148   call MPI_BARRIER( MPI_COMM_WORLD, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> )   ! Wait for other PEs to catch up
<a name="l00149"></a>00149 
<a name="l00150"></a>00150   call MPI_ALLGATHER( nactive, 1, MPI_INTEGER, nactives, 1, MPI_INTEGER, MPI_COMM_WORLD, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> )
<a name="l00151"></a>00151 
<a name="l00152"></a>00152   maxactive = maxval(nactives)
<a name="l00153"></a>00153 
<a name="l00154"></a>00154   ntraversals = 0
<a name="l00155"></a>00155   nlast_child = 0
<a name="l00156"></a>00156   sum_nhops = 0
<a name="l00157"></a>00157   sum_inner_pass = 0
<a name="l00158"></a>00158   if (sum_nhops_old &lt; 0) then
<a name="l00159"></a>00159      hops(1) = sum_nhops_old*0.9 
<a name="l00160"></a>00160      hops(2:4) = hops(1:3)*0.2
<a name="l00161"></a>00161      hops(5:21) = 2**30
<a name="l00162"></a>00162   else
<a name="l00163"></a>00163      hops = 2**30    ! First time round set infinite - finish all traversals
<a name="l00164"></a>00164      !     hops(1) = 500
<a name="l00165"></a>00165   endif
<a name="l00166"></a>00166 
<a name="l00167"></a>00167   do while (maxactive &gt; 0)        ! Outer loop over 'active' traversals
<a name="l00168"></a>00168 
<a name="l00169"></a>00169      !POMP$ INST BEGIN(walk_local)
<a name="l00170"></a>00170 
<a name="l00171"></a>00171      call cputime(tw1)
<a name="l00172"></a>00172      ntraversals = ntraversals + 1  ! # Tree-walks
<a name="l00173"></a>00173      if (<a class="code" href="namespacetreevars.html#415096877a1abe9a37d0435e96d0f30a">walk_debug</a>) write(<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,'(a,i6)') 'Start of traversal ',ntraversals
<a name="l00174"></a>00174      !     if (<a class="code" href="namespacetreevars.html#415096877a1abe9a37d0435e96d0f30a">walk_debug</a>) write(*,'(a,i6)') 'Start of traversal ',ntraversals
<a name="l00175"></a>00175 
<a name="l00176"></a>00176      finished(1:<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>) = .false.  ! label all particles not finished
<a name="l00177"></a>00177      ndefer(1:npshort) = 0          ! Zero # deferrals (absolute particle number)
<a name="l00178"></a>00178 
<a name="l00179"></a>00179      nshare = 0                   ! Total number of requests for nonlocal keys
<a name="l00180"></a>00180      nplace = 0                   ! Total # non-local children to be fetched
<a name="l00181"></a>00181      nchild_ship = 0              ! Total # local children to be shipped
<a name="l00182"></a>00182      newleaf = 0
<a name="l00183"></a>00183      newtwig = 0                  ! local bookkeeping
<a name="l00184"></a>00184      inner_pass = 0
<a name="l00185"></a>00185      nhops = 0
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 
<a name="l00188"></a>00188      do while (<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>&gt;0 .and. nhops &lt;= hops(ntraversals) )        ! Inner loop - single hop in tree walk
<a name="l00189"></a>00189         inner_pass = inner_pass+1        ! statistics
<a name="l00190"></a>00190         nhops = nhops + <a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>
<a name="l00191"></a>00191         sum_nhops = sum_nhops + <a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>
<a name="l00192"></a>00192         sum_inner_pass = sum_inner_pass + 1
<a name="l00193"></a>00193 !        write (*,*) 'inner_pass',inner_pass,'<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>=',<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>
<a name="l00194"></a>00194         do i=1,<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>
<a name="l00195"></a>00195            p = plist(i)  ! particle index
<a name="l00196"></a>00196            walk_addr =  <a class="code" href="get__address_8f90.html#2809b00e2dcb999b654cac13b2ffb261">key2addr</a>( walk_key(i),'WALK: local ' )     ! get <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a> <a class="code" href="namespacetreevars.html#3ecc2e98e400f5751ae1758d72035e15">address</a>
<a name="l00197"></a>00197            walk_node = <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( walk_addr )%node             ! Walk node index - points to multipole moments  
<a name="l00198"></a>00198            walk_next = <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( walk_addr )%next             ! Next node pointer 
<a name="l00199"></a>00199 
<a name="l00200"></a>00200            cbyte = <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( walk_addr )%childcode        ! Children byte-code
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 
<a name="l00203"></a>00203            ! children of local/non-local parents already fetched: HERE flag
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 
<a name="l00206"></a>00206            dx = <a class="code" href="namespacetreevars.html#466130ce7b2fb1b56c99a0524b270b70">x</a>( pshort(p) ) - <a class="code" href="namespacetreevars.html#4d053c9047892373590cadde565e3987">xcoc</a>( walk_node )      ! Separations
<a name="l00207"></a>00207            dy = <a class="code" href="namespacetreevars.html#5ca0fa6d04b09531b6c4c55c545bde27">y</a>( pshort(p) ) - <a class="code" href="namespacetreevars.html#12a758eeb25f419290c25611e464f6d5">ycoc</a>( walk_node )
<a name="l00208"></a>00208            dz = <a class="code" href="namespacetreevars.html#a73b1827f715edeb1801dbd9ea9bd930">z</a>( pshort(p) ) - <a class="code" href="namespacetreevars.html#670ff1fa3088f3e7884811892883a9aa">zcoc</a>( walk_node )
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 !           write (*,'(a,4i8,o15,f12.3)') 'particle i,p,pshort(p),<a class="code" href="namespacetreevars.html#0c00c9ba3fcb9b5b155b47f4a1df1011">nterm</a>,kwalk,<a class="code" href="namespacetreevars.html#466130ce7b2fb1b56c99a0524b270b70">x</a>', &amp;
<a name="l00211"></a>00211 !                i,p,pshort(p),<a class="code" href="namespacetreevars.html#0c00c9ba3fcb9b5b155b47f4a1df1011">nterm</a>(p),walk_key(i),<a class="code" href="namespacetreevars.html#466130ce7b2fb1b56c99a0524b270b70">x</a>(pshort(p))
<a name="l00212"></a>00212 
<a name="l00213"></a>00213            s2 = boxlength2( <a class="code" href="namespacetreevars.html#4806e1728d085ba63091689ed4e089a2">node_level</a>(walk_node) )
<a name="l00214"></a>00214            dist2 = dx**2+dy**2+dz**2
<a name="l00215"></a>00215            mac_ok = ( s2 &lt; dist2*theta2 .and. walk_key(i)&gt;1 )   ! Preprocess MAC - always reject root node
<a name="l00216"></a>00216 
<a name="l00217"></a>00217            ! set ignore flag if leaf node corresponds to particle itself (number in pshort)
<a name="l00218"></a>00218            ! NB: this uses local leaf #, not global particle label
<a name="l00219"></a>00219 
<a name="l00220"></a>00220            ignore =  ( pshort(p) == <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( walk_addr )%node )
<a name="l00221"></a>00221 
<a name="l00222"></a>00222            ! Wakefield QSA <a class="code" href="namelist_8h.html#051ba9b635fca70611c05a5b65e92cd1">mac</a> condition: prevent forward transmission of pw info
<a name="l00223"></a>00223            if (<a class="code" href="namelist_8h.html#051ba9b635fca70611c05a5b65e92cd1">mac</a>==5) then
<a name="l00224"></a>00224              ignore = (ignore .or. dx&lt;0) 
<a name="l00225"></a>00225            else if (<a class="code" href="namelist_8h.html#051ba9b635fca70611c05a5b65e92cd1">mac</a>==1) then
<a name="l00226"></a>00226              ignore = (ignore .or. dist2 &gt; 25*<a class="code" href="namelist_8h.html#3d5b0f2d79621403cfab74bce3469eb1">eps</a>**2) ! impose cutoff at 5*<a class="code" href="namelist_8h.html#3d5b0f2d79621403cfab74bce3469eb1">eps</a>
<a name="l00227"></a>00227            endif
<a name="l00228"></a>00228         
<a name="l00229"></a>00229            add_key = walk_key(i)                                ! Remember current key
<a name="l00230"></a>00230 
<a name="l00231"></a>00231            ! Possible courses of action:
<a name="l00232"></a>00232            
<a name="l00233"></a>00233            ! 1) MAC test OK, so put cell on interaction list and find next node for tree walk
<a name="l00234"></a>00234            !    - reject self
<a name="l00235"></a>00235 
<a name="l00236"></a>00236            if ( (mac_ok .or. walk_node &gt;0) .and. .not.ignore) then
<a name="l00237"></a>00237               walk_key(i) = walk_next
<a name="l00238"></a>00238               entry_next = <a class="code" href="namespacetreevars.html#0c00c9ba3fcb9b5b155b47f4a1df1011">nterm</a>(p) + 1
<a name="l00239"></a>00239               <a class="code" href="namespacetreevars.html#f99b61fd87d2273b634f6cb97c1f920c">intlist</a>( entry_next, p ) = add_key      ! Augment interaction list - only need keys for diagnosis
<a name="l00240"></a>00240               <a class="code" href="namespacetreevars.html#038c4e890b46de1d1dce97658d24652c">nodelist</a>( entry_next, p ) = walk_node   ! Node number for <a class="code" href="sum__force_8f90.html#e63caebbd96a0eb2def083dfd8a1b5f3">sum_force</a>
<a name="l00241"></a>00241               <a class="code" href="namespacetreevars.html#0c00c9ba3fcb9b5b155b47f4a1df1011">nterm</a>(p) = entry_next
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 
<a name="l00244"></a>00244               ! 2) MAC fails at node for which children present, so resolve cell &amp; put 1st child on walk_list
<a name="l00245"></a>00245 
<a name="l00246"></a>00246            else  if ( .not.mac_ok .and. walk_node &lt; 0 .and. btest(cbyte,9) ) then
<a name="l00247"></a>00247               ! if local put 1st child node on walk_list
<a name="l00248"></a>00248               walk_key(i) = <a class="code" href="namespacetreevars.html#368a06dc09d689328cc73ddf69490a3f">first_child</a>( walk_node )
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 
<a name="l00251"></a>00251               ! 3) MAC fails at node for which children _absent_, so put node on REQUEST list (flag with add=2)
<a name="l00252"></a>00252 
<a name="l00253"></a>00253            else if ( .not.mac_ok .and. walk_node &lt; 0 .and.  .not. btest(cbyte,9) ) then
<a name="l00254"></a>00254               walk_key(i) = walk_next  ! Continue with walk for now
<a name="l00255"></a>00255               ndefer(p) = ndefer(p) + 1
<a name="l00256"></a>00256               defer_list( ndefer( p), p ) = add_key  ! Deferred list of nodes to search, pending request
<a name="l00257"></a>00257               ! for data from nonlocal PEs
<a name="l00258"></a>00258               if (.not. BTEST( <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>(walk_addr)%childcode, 8 ) ) then  ! Check if node already requested
<a name="l00259"></a>00259                  nshare = nshare + 1
<a name="l00260"></a>00260 
<a name="l00261"></a>00261                  request_key(nshare) = add_key       ! New request key
<a name="l00262"></a>00262                  own = <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( walk_addr )%owner           ! Owner 
<a name="l00263"></a>00263                  request_owner(nshare) = own
<a name="l00264"></a>00264                  nplace(own) = nplace(own) + <a class="code" href="namespacetreevars.html#273d43aa2e27f0f2d74fa02458d54d2d">n_children</a>(walk_node)     ! Total # children to be fetched from remote PEs
<a name="l00265"></a>00265                  <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>(walk_addr)%childcode   =  IBSET( <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>(walk_addr)%childcode, 8 ) ! Set requested flag
<a name="l00266"></a>00266 
<a name="l00267"></a>00267               endif
<a name="l00268"></a>00268 
<a name="l00269"></a>00269               ! 1) particle and leaf node identical, so skip
<a name="l00270"></a>00270 
<a name="l00271"></a>00271            else
<a name="l00272"></a>00272               walk_key(i) = walk_next
<a name="l00273"></a>00273 
<a name="l00274"></a>00274            endif
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 
<a name="l00277"></a>00277            ! Trap condition for last of nonlocal children - fetch next deferred node from walk_list
<a name="l00278"></a>00278            if (walk_key(i) == -1 )  then       
<a name="l00279"></a>00279               defer_ctr(p) = defer_ctr(p) + 1
<a name="l00280"></a>00280               walk_key(i) = walk_list (defer_ctr(p),p ) ! Select next deferred node from walk list for particle plist(i)
<a name="l00281"></a>00281            endif
<a name="l00282"></a>00282 
<a name="l00283"></a>00283            walk_last(p) = walk_key(i)  ! Store last reached in traversal
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 
<a name="l00286"></a>00286            ! Check for completed traversals
<a name="l00287"></a>00287            if ( walk_key(i) == 1 )  then  ! Reached root  
<a name="l00288"></a>00288               finished(i) = .true.    ! Flag particles whose local walks are complete
<a name="l00289"></a>00289               defer_ctr(p) = defer_ctr(p) + 1
<a name="l00290"></a>00290 
<a name="l00291"></a>00291            else 
<a name="l00292"></a>00292               finished(i) = .false. 
<a name="l00293"></a>00293            endif
<a name="l00294"></a>00294         end do
<a name="l00295"></a>00295 
<a name="l00296"></a>00296         !        nnew = count( mask = .not.finished(1:<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>) )            ! Count remaining particles
<a name="l00297"></a>00297 
<a name="l00298"></a>00298         !        plist(1:nnew) =  pack( plist(1:<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>), mask = .not.finished(1:<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>) )    ! Compress particle index list
<a name="l00299"></a>00299         !        walk_key(1:nnew) =  pack( walk_key(1:<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>), mask = .not.finished(1:<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>) )       ! Compress walk lists etc.
<a name="l00300"></a>00300         nnew=0
<a name="l00301"></a>00301         do i=1,<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>
<a name="l00302"></a>00302            if (.not.finished(i)) then
<a name="l00303"></a>00303               nnew=nnew+1
<a name="l00304"></a>00304               plist(nnew) = plist(i)
<a name="l00305"></a>00305               walk_key(nnew) = walk_key(i)
<a name="l00306"></a>00306            endif
<a name="l00307"></a>00307         end do
<a name="l00308"></a>00308 
<a name="l00309"></a>00309         <a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a> = nnew
<a name="l00310"></a>00310 
<a name="l00311"></a>00311      end do   ! END DO_WHILE
<a name="l00312"></a>00312 
<a name="l00313"></a>00313      ! For remaining unfinished particles, need to copy rest of walk_list (still not inspected)
<a name="l00314"></a>00314      ! back onto defer list.
<a name="l00315"></a>00315 
<a name="l00316"></a>00316      do i=1,npshort
<a name="l00317"></a>00317         ndef = ndefer(i)  ! # new deferrals added to defer_list during traversal
<a name="l00318"></a>00318         nrest = nwalk(i)-defer_ctr(i) + 1  ! # unprocessed deferrals from previous fetch
<a name="l00319"></a>00319         if (nrest&gt;0) then  
<a name="l00320"></a>00320            ! Augment defer list with rest of walk_list
<a name="l00321"></a>00321            defer_list(ndef+1:ndef+nrest,i) = walk_list(defer_ctr(i):nwalk(i),i)
<a name="l00322"></a>00322            ndefer(i) = ndefer(i) + nrest
<a name="l00323"></a>00323         endif
<a name="l00324"></a>00324         if (walk_last(i) /= 1) then
<a name="l00325"></a>00325            defer_list(ndef+nrest+1,i) = walk_last(i)  ! Tack on key where local walk was interrupted
<a name="l00326"></a>00326            ndefer(i) = ndefer(i) + 1
<a name="l00327"></a>00327         endif
<a name="l00328"></a>00328 
<a name="l00329"></a>00329      end do
<a name="l00330"></a>00330 
<a name="l00331"></a>00331      call cputime(tw2)
<a name="l00332"></a>00332      twalk=twalk+tw2-tw1
<a name="l00333"></a>00333      !POMP$ INST END(walk_local)
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 
<a name="l00336"></a>00336      if (<a class="code" href="namespacetreevars.html#415096877a1abe9a37d0435e96d0f30a">walk_debug</a>) then
<a name="l00337"></a>00337         write(<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,'(a/(o15,i7))') 'Shared request list: ',(request_key(i),<a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( <a class="code" href="get__address_8f90.html#2809b00e2dcb999b654cac13b2ffb261">key2addr</a>( request_key(i),'WALK: after local' ) )%owner,i=1,nshare)
<a name="l00338"></a>00338         !        if (<a class="code" href="namespacetreevars.html#f0c1ebe7c983f1b1061d88e367afc933">me</a>==2) then
<a name="l00339"></a>00339         !           write(*,'(a/(o15,i7))') 'Shared request list: ',(request_key(i),<a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( <a class="code" href="get__address_8f90.html#2809b00e2dcb999b654cac13b2ffb261">key2addr</a>( request_key(i) ) )%owner,i=1,nshare)
<a name="l00340"></a>00340         !        endif
<a name="l00341"></a>00341      endif
<a name="l00342"></a>00342      ! At this point all particles have completed their walks with the locally available tree data.
<a name="l00343"></a>00343      ! Each PE has list of nonlocal nodes which have been requested during these walks - request_key(1:nshare)
<a name="l00344"></a>00344      ! Need to ship these requests to the PEs on which the child-data is actually held (cf particle swapping).
<a name="l00345"></a>00345 
<a name="l00346"></a>00346      ! First find out how many requests are to be sent to each PE.
<a name="l00347"></a>00347 
<a name="l00348"></a>00348      nfetches(0:<a class="code" href="namespacetreevars.html#694640a77e3d8236c59add8bfa3c133b">num_pe</a>-1) = (/ (count( mask = request_owner(1:nshare) == ipe ), ipe=0,<a class="code" href="namespacetreevars.html#694640a77e3d8236c59add8bfa3c133b">num_pe</a>-1) /)
<a name="l00349"></a>00349 
<a name="l00350"></a>00350      !POMP$ INST BEGIN(exchange)
<a name="l00351"></a>00351 
<a name="l00352"></a>00352      call MPI_BARRIER( MPI_COMM_WORLD, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> )   ! Wait for other PEs to catch up
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 
<a name="l00355"></a>00355      ! Exchange numbers of keys to be shipped and requested
<a name="l00356"></a>00356 
<a name="l00357"></a>00357      call MPI_ALLTOALL( nfetches, 1, MPI_INTEGER, nrequests, 1, MPI_INTEGER, MPI_COMM_WORLD, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> )
<a name="l00358"></a>00358 
<a name="l00359"></a>00359      if (<a class="code" href="namespacetreevars.html#415096877a1abe9a37d0435e96d0f30a">walk_debug</a>) then
<a name="l00360"></a>00360         write (<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,*) 'PE ',<a class="code" href="namespacetreevars.html#f0c1ebe7c983f1b1061d88e367afc933">me</a>,': Keys to request: ',nfetches(0:<a class="code" href="namespacetreevars.html#694640a77e3d8236c59add8bfa3c133b">num_pe</a>-1),' to process: ',nrequests(0:<a class="code" href="namespacetreevars.html#694640a77e3d8236c59add8bfa3c133b">num_pe</a>-1)
<a name="l00361"></a>00361      endif
<a name="l00362"></a>00362 
<a name="l00363"></a>00363 
<a name="l00364"></a>00364      ! Initiate receives for incoming request keys: could reuse shared request list
<a name="l00365"></a>00365      istart(<a class="code" href="namespacetreevars.html#f0c1ebe7c983f1b1061d88e367afc933">me</a>) = 0    ! Starting point of key list for given rank
<a name="l00366"></a>00366      i1=1
<a name="l00367"></a>00367      request_count = 0
<a name="l00368"></a>00368      ipack = 0
<a name="l00369"></a>00369 
<a name="l00370"></a>00370      do ipe = 0,<a class="code" href="namespacetreevars.html#694640a77e3d8236c59add8bfa3c133b">num_pe</a>-1
<a name="l00371"></a>00371         if ( ipe /= <a class="code" href="namespacetreevars.html#f0c1ebe7c983f1b1061d88e367afc933">me</a> .and. nrequests(ipe) &gt; 0 ) then   ! skip self or if nothing requested
<a name="l00372"></a>00372            istart(ipe) = i1
<a name="l00373"></a>00373            request_count = request_count + 1  ! receive counter
<a name="l00374"></a>00374            call MPI_IRECV( process_key(i1), nrequests(ipe), MPI_INTEGER8, ipe, tag1, &amp;
<a name="l00375"></a>00375                 MPI_COMM_WORLD, recv_key_handle(request_count), <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a>)
<a name="l00376"></a>00376            i1 = i1+nrequests(ipe)
<a name="l00377"></a>00377         endif
<a name="l00378"></a>00378      end do
<a name="l00379"></a>00379 
<a name="l00380"></a>00380 
<a name="l00381"></a>00381      ! Can now ship the keys in the request lists to the PEs where the data sits:
<a name="l00382"></a>00382      !   the recipients already know how many requests to expect.
<a name="l00383"></a>00383 
<a name="l00384"></a>00384      i1=1
<a name="l00385"></a>00385      fetch_pe_count = 0
<a name="l00386"></a>00386      iship1=1
<a name="l00387"></a>00387      if (nshare&gt;0) then
<a name="l00388"></a>00388         !  Sort according to PE
<a name="l00389"></a>00389         call indexsort(request_owner,reqlist,nshare,<a class="code" href="namespacetreevars.html#88ddb99cee17ffd203ed6e3adbdebaa5">maxaddress</a>)
<a name="l00390"></a>00390         do i=1,nshare
<a name="l00391"></a>00391            ship_keys(i) = request_key(reqlist(i))
<a name="l00392"></a>00392         end do
<a name="l00393"></a>00393      endif
<a name="l00394"></a>00394 
<a name="l00395"></a>00395      if (<a class="code" href="namespacetreevars.html#415096877a1abe9a37d0435e96d0f30a">walk_debug</a>) then
<a name="l00396"></a>00396         write(<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,'(a/(o15,i7))') 'Sorted request list: ',(ship_keys(i),request_owner(reqlist(i)),i=1,nshare)
<a name="l00397"></a>00397      endif
<a name="l00398"></a>00398 
<a name="l00399"></a>00399      do ipe = 0,<a class="code" href="namespacetreevars.html#694640a77e3d8236c59add8bfa3c133b">num_pe</a>-1 
<a name="l00400"></a>00400 
<a name="l00401"></a>00401         if ( ipe /= <a class="code" href="namespacetreevars.html#f0c1ebe7c983f1b1061d88e367afc933">me</a> .and. nfetches(ipe) &gt; 0 ) then   ! avoid shipping to oneself and shipping nothing
<a name="l00402"></a>00402 
<a name="l00403"></a>00403            ic_start(ipe) = i1        ! fencepost
<a name="l00404"></a>00404            fetch_pe_count = fetch_pe_count + 1  ! receive counter
<a name="l00405"></a>00405 
<a name="l00406"></a>00406            ! First initiate receives for returning child info
<a name="l00407"></a>00407            call MPI_IRECV( <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(i1), nplace(ipe), MPI_type_multipole, ipe, tag1, &amp;
<a name="l00408"></a>00408                 MPI_COMM_WORLD, recv_child_handle(fetch_pe_count), <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a>)
<a name="l00409"></a>00409            i1 = i1+nplace(ipe)
<a name="l00410"></a>00410 
<a name="l00411"></a>00411            ! Extract sub-list of keys to request according to location - don't overwrite buffer!
<a name="l00412"></a>00412 
<a name="l00413"></a>00413            !           ship_keys(iship1:iship1+nfetches(ipe)) = pack(request_key(1:nshare), mask = request_owner(1:nshare) == ipe )
<a name="l00414"></a>00414 
<a name="l00415"></a>00415            if (emulate_blocking) then
<a name="l00416"></a>00416               call MPI_SEND(ship_keys(iship1), nfetches(ipe), MPI_INTEGER8, ipe, tag1, &amp;
<a name="l00417"></a>00417                    MPI_COMM_WORLD,  <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> ) ! Ship to data location
<a name="l00418"></a>00418            else
<a name="l00419"></a>00419               call MPI_ISEND(ship_keys(iship1), nfetches(ipe), MPI_INTEGER8, ipe, tag1, &amp;
<a name="l00420"></a>00420                    MPI_COMM_WORLD, send_key_handle(fetch_pe_count), <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> ) ! Ship to data location
<a name="l00421"></a>00421               call MPI_REQUEST_FREE( send_key_handle(fetch_pe_count), <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a>)
<a name="l00422"></a>00422            endif
<a name="l00423"></a>00423            iship1=iship1 + nfetches(ipe)  ! Increment buffer marker
<a name="l00424"></a>00424         endif
<a name="l00425"></a>00425      end do
<a name="l00426"></a>00426 
<a name="l00427"></a>00427      ! Now have complete list of requests from all PEs in rank order. 
<a name="l00428"></a>00428      ! Fetch child data from local <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a> and send back to requesting PE (recipient already knows how many children to expect)
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 
<a name="l00431"></a>00431      ! Wait for child request and ship
<a name="l00432"></a>00432 
<a name="l00433"></a>00433      ic1 = 1
<a name="l00434"></a>00434      send_prop_count = 0
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 
<a name="l00437"></a>00437      do iwait = 1,request_count
<a name="l00438"></a>00438         call MPI_WAITANY( request_count, recv_key_handle, ihand, status, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a>)  ! Wait for one of receives to complete
<a name="l00439"></a>00439         ipe = status(MPI_SOURCE)    ! which PE sent it?
<a name="l00440"></a>00440         nreqs = nrequests(ipe)  ! # parent keys
<a name="l00441"></a>00441         i1 = istart(ipe)
<a name="l00442"></a>00442         i2 = istart(ipe) + nrequests(ipe) - 1
<a name="l00443"></a>00443         if (<a class="code" href="namespacetreevars.html#415096877a1abe9a37d0435e96d0f30a">walk_debug</a>) then
<a name="l00444"></a>00444            write(<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,'(a,i4,a,3i7/(o12))') 'PE ',<a class="code" href="namespacetreevars.html#f0c1ebe7c983f1b1061d88e367afc933">me</a>,' received request from: ',ipe,nrequests(ipe),istart(ipe),process_key(i1:i2) 
<a name="l00445"></a>00445         endif
<a name="l00446"></a>00446         process_addr(1:nreqs) = (/( <a class="code" href="get__address_8f90.html#2809b00e2dcb999b654cac13b2ffb261">key2addr</a>( process_key(j),'WALK: ship1 '),j=i1,i2)/)    ! get <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a> addresses
<a name="l00447"></a>00447         childbyte(1:nreqs) = <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( process_addr(1:nreqs) )%childcode        !  Children byte-code
<a name="l00448"></a>00448 
<a name="l00449"></a>00449 
<a name="l00450"></a>00450         ! For each key in the request list, fetch and package tree info for children
<a name="l00451"></a>00451 
<a name="l00452"></a>00452         do i=1,nreqs
<a name="l00453"></a>00453            ipack = i1+i-1   ! Request number: this needs to be unique for each SEND, otherwise buffer <a class="code" href="namespacetreevars.html#579c49c8e8bc7fd7f0f16ca93fb8151c">pack_child</a>(..,ipack)
<a name="l00454"></a>00454            ! may get overwritten before send actually completes
<a name="l00455"></a>00455            nchild = SUM( (/ (ibits(childbyte(i),j,1),j=0,7) /) )                     ! Get # children
<a name="l00456"></a>00456            nchild_ship(ipe) = nchild_ship(ipe) + nchild  ! Total # children to be shipped
<a name="l00457"></a>00457 
<a name="l00458"></a>00458            sub_key(1:nchild) = pack( <a class="code" href="namespacetreevars.html#e81ec702e5854eb659b60ed694d2f732">bitarr</a>, mask=(/ (btest(childbyte(i),j),j=0,7) /) )      ! Extract sub key from byte code
<a name="l00459"></a>00459            key_child(1:nchild) = IOR( ishft( process_key(ipack),3 ), sub_key(1:nchild) ) ! Construct keys of children
<a name="l00460"></a>00460            addr_child(1:nchild) = (/( <a class="code" href="get__address_8f90.html#2809b00e2dcb999b654cac13b2ffb261">key2addr</a>( key_child(j),'WALK: ship2 ' ),j=1,nchild)/)                 ! Table <a class="code" href="namespacetreevars.html#3ecc2e98e400f5751ae1758d72035e15">address</a> of children
<a name="l00461"></a>00461            node_child(1:nchild) = <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( addr_child(1:nchild) )%node                        ! Child node index  
<a name="l00462"></a>00462            byte_child(1:nchild) = IAND( <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( addr_child(1:nchild) )%childcode,255 )        ! Catch lowest 8 bits of childbyte - filter off requested and here flags 
<a name="l00463"></a>00463            leaves_child(1:nchild) = <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( addr_child(1:nchild) )%leaves                    ! # contained leaves
<a name="l00464"></a>00464            next_child(1:nchild-1) = <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( addr_child(1:nchild-1) )%next                    ! # next-node pointer
<a name="l00465"></a>00465            next_child(nchild) = -1                             ! Last child gets pointed back to _parent_ for non-local nodes
<a name="l00466"></a>00466            ! This is used to distinguish particles' walks during 'defer' <a class="code" href="namespaceutils.html#612945b4c6bbd6edfaba993867107c81">phase</a>
<a name="l00467"></a>00467 
<a name="l00468"></a>00468            ! Package children properties into user-defined multipole array for shipping
<a name="l00469"></a>00469            do ic = 1,nchild
<a name="l00470"></a>00470               send_prop_count = send_prop_count+1
<a name="l00471"></a>00471               <a class="code" href="namespacetreevars.html#579c49c8e8bc7fd7f0f16ca93fb8151c">pack_child</a>(send_prop_count) = multipole ( key_child(ic), &amp;
<a name="l00472"></a>00472                    byte_child(ic), &amp;
<a name="l00473"></a>00473                    leaves_child(ic), &amp;
<a name="l00474"></a>00474                    <a class="code" href="namespacetreevars.html#f0c1ebe7c983f1b1061d88e367afc933">me</a>, &amp;
<a name="l00475"></a>00475                    next_child(ic), &amp;
<a name="l00476"></a>00476                    <a class="code" href="namespacetreevars.html#c635f0d036ac28a9d50d9a34ce023562">charge</a>( node_child(ic) ), &amp;
<a name="l00477"></a>00477                    <a class="code" href="namespacetreevars.html#833874545f1ee36b5e31b4dfa3dc11d3">abs_charge</a>( node_child(ic) ), &amp;
<a name="l00478"></a>00478                    <a class="code" href="namespacetreevars.html#4d053c9047892373590cadde565e3987">xcoc</a>( node_child(ic)), &amp;
<a name="l00479"></a>00479                    <a class="code" href="namespacetreevars.html#12a758eeb25f419290c25611e464f6d5">ycoc</a>( node_child(ic)), &amp;
<a name="l00480"></a>00480                    <a class="code" href="namespacetreevars.html#670ff1fa3088f3e7884811892883a9aa">zcoc</a>( node_child(ic)), &amp;
<a name="l00481"></a>00481                    <a class="code" href="namespacetreevars.html#3dd15b2d32e2287f4cb38816e1aaec30">xdip</a>( node_child(ic)), &amp;
<a name="l00482"></a>00482                    <a class="code" href="namespacetreevars.html#20ca9029cf1ae376692b319a202ec4a7">ydip</a>( node_child(ic)), &amp;
<a name="l00483"></a>00483                    <a class="code" href="namespacetreevars.html#60326fe33c337b0da29aa828d6da9dae">zdip</a>( node_child(ic)), &amp;
<a name="l00484"></a>00484                    <a class="code" href="namespacetreevars.html#fd025a204b3181aebd5d1833a115c037">xxquad</a>( node_child(ic)), &amp;
<a name="l00485"></a>00485                    <a class="code" href="namespacetreevars.html#bfa839ef19e3616ca2e8aa110192d3e2">yyquad</a>( node_child(ic)), &amp;
<a name="l00486"></a>00486                    <a class="code" href="namespacetreevars.html#1d3755f0ab2dca3b2f14d23c0c064dc2">zzquad</a>( node_child(ic)), &amp;
<a name="l00487"></a>00487                    <a class="code" href="namespacetreevars.html#bb2261d5c9c8a1c62ad5a8ff6c4b1e0b">xyquad</a>( node_child(ic)), &amp;
<a name="l00488"></a>00488                    <a class="code" href="namespacetreevars.html#7b35d76a055c6765224fd8776d87bff8">yzquad</a>( node_child(ic)), &amp;
<a name="l00489"></a>00489                    <a class="code" href="namespacetreevars.html#208c8681eab779b3d1b7105d4c7dab4a">zxquad</a>( node_child(ic)), &amp;
<a name="l00490"></a>00490                    <a class="code" href="namespacetreevars.html#a638e02fa2630a6f9ee865fdcf1b733b">jx</a>( node_child(ic)), &amp;
<a name="l00491"></a>00491                    <a class="code" href="namespacetreevars.html#95a1f21026d31cde85296c2d91e18b70">jy</a>( node_child(ic)), &amp;
<a name="l00492"></a>00492                    <a class="code" href="namespacetreevars.html#e2ea5dfe327e1571ddbd3bc9e2d4b79d">jz</a>( node_child(ic)), &amp;
<a name="l00493"></a>00493                    <a class="code" href="namespacetreevars.html#79cc90053d5078b57074a25ff5889b4c">magmx</a>( node_child(ic)), &amp;
<a name="l00494"></a>00494                    <a class="code" href="namespacetreevars.html#c5f25ca5b0581069057e0ac7b5d90939">magmy</a>( node_child(ic)), &amp;
<a name="l00495"></a>00495                    <a class="code" href="namespacetreevars.html#0ffed3c46e462545a7b60d8478dc0bcc">magmz</a>( node_child(ic)) )
<a name="l00496"></a>00496 
<a name="l00497"></a>00497            end do
<a name="l00498"></a>00498 
<a name="l00499"></a>00499            !  Keep record of # requested child keys
<a name="l00500"></a>00500            <a class="code" href="namespacetreevars.html#c56353fcc7cc41b4f1f42d0a50cc4d64">nreqs_total</a>(ipe) = <a class="code" href="namespacetreevars.html#c56353fcc7cc41b4f1f42d0a50cc4d64">nreqs_total</a>(ipe) + nchild  ! Record cumulative total of # children requested 
<a name="l00501"></a>00501            <a class="code" href="namespacetreevars.html#39c17ce55445417f27b9051800fca4cc">requested_keys</a>(<a class="code" href="namespacetreevars.html#98a5e67d24ae4f0fe88492d6cf4f77a9">sum_ships</a>+1:<a class="code" href="namespacetreevars.html#98a5e67d24ae4f0fe88492d6cf4f77a9">sum_ships</a>+nchild) = key_child(1:nchild)  ! Keep record of multipole ships
<a name="l00502"></a>00502            <a class="code" href="namespacetreevars.html#e05d1a9d4583e84923db6cff4aa9cb4e">requested_owner</a>(<a class="code" href="namespacetreevars.html#98a5e67d24ae4f0fe88492d6cf4f77a9">sum_ships</a>+1:<a class="code" href="namespacetreevars.html#98a5e67d24ae4f0fe88492d6cf4f77a9">sum_ships</a>+nchild) = ipe  ! where requests came from
<a name="l00503"></a>00503            <a class="code" href="namespacetreevars.html#98a5e67d24ae4f0fe88492d6cf4f77a9">sum_ships</a> = <a class="code" href="namespacetreevars.html#98a5e67d24ae4f0fe88492d6cf4f77a9">sum_ships</a> + nchild
<a name="l00504"></a>00504 
<a name="l00505"></a>00505            if (<a class="code" href="namespacetreevars.html#415096877a1abe9a37d0435e96d0f30a">walk_debug</a>) then
<a name="l00506"></a>00506               write(<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,'(a,i4,i7/(o12))') 'Keys requested from: ',ipe,nchild,key_child(1:nchild) 
<a name="l00507"></a>00507            endif
<a name="l00508"></a>00508         end do
<a name="l00509"></a>00509 
<a name="l00510"></a>00510         ! Ship child data back to PE that requested it
<a name="l00511"></a>00511 
<a name="l00512"></a>00512         if (emulate_blocking) then
<a name="l00513"></a>00513            call MPI_SEND( <a class="code" href="namespacetreevars.html#579c49c8e8bc7fd7f0f16ca93fb8151c">pack_child</a>(ic1), nchild_ship, MPI_type_multipole, ipe, tag1, MPI_COMM_WORLD, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> )
<a name="l00514"></a>00514         else
<a name="l00515"></a>00515            call MPI_ISEND( <a class="code" href="namespacetreevars.html#579c49c8e8bc7fd7f0f16ca93fb8151c">pack_child</a>(ic1), nchild_ship(ipe), MPI_type_multipole, ipe, tag1,&amp;
<a name="l00516"></a>00516                 MPI_COMM_WORLD, send_child_handle(iwait), <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> )
<a name="l00517"></a>00517            call MPI_REQUEST_FREE(send_child_handle(iwait), <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a>) 
<a name="l00518"></a>00518         endif
<a name="l00519"></a>00519 
<a name="l00520"></a>00520         ic1 = ic1 + nchild_ship(ipe)  ! increment start position
<a name="l00521"></a>00521 
<a name="l00522"></a>00522         if (<a class="code" href="namespacetreevars.html#415096877a1abe9a37d0435e96d0f30a">walk_debug</a>) write(<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,*) 'Total children shipped to processor ',ipe,' from ',<a class="code" href="namespacetreevars.html#f0c1ebe7c983f1b1061d88e367afc933">me</a>,' was', nchild_ship(ipe) 
<a name="l00523"></a>00523 
<a name="l00524"></a>00524      end do
<a name="l00525"></a>00525 
<a name="l00526"></a>00526      nchild_ship_tot = ic1-1  ! Total # children shipped to all non-local procs
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 
<a name="l00529"></a>00529      ! Wait for data to arrive
<a name="l00530"></a>00530 
<a name="l00531"></a>00531      do i=1, fetch_pe_count  ! loop over # PEs originally sent requests
<a name="l00532"></a>00532 
<a name="l00533"></a>00533         call MPI_WAITANY( fetch_pe_count, recv_child_handle, ihand, status, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a>)  ! Wait for one of receives to complete
<a name="l00534"></a>00534         ipe = status(MPI_SOURCE)   ! which PE?
<a name="l00535"></a>00535         ic1 = ic_start(ipe)         ! fenceposts
<a name="l00536"></a>00536         ic2 = ic1 + nplace(ipe) -1
<a name="l00537"></a>00537         do ic = ic1, ic2
<a name="l00538"></a>00538            kchild = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%key
<a name="l00539"></a>00539            kparent = ishft( kchild,-3 )
<a name="l00540"></a>00540            bchild = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%byte
<a name="l00541"></a>00541            lchild = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%leaves
<a name="l00542"></a>00542            nxchild = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%next
<a name="l00543"></a>00543 
<a name="l00544"></a>00544            if (lchild ==1 ) then
<a name="l00545"></a>00545               newleaf = newleaf + 1
<a name="l00546"></a>00546               <a class="code" href="namespacetreevars.html#fb6610fee5c52c51b8f7cc46ce975c16">nleaf</a> = <a class="code" href="namespacetreevars.html#fb6610fee5c52c51b8f7cc46ce975c16">nleaf</a> + 1
<a name="l00547"></a>00547               nodchild = <a class="code" href="namespacetreevars.html#fb6610fee5c52c51b8f7cc46ce975c16">nleaf</a>
<a name="l00548"></a>00548               <a class="code" href="namespacetreevars.html#273d43aa2e27f0f2d74fa02458d54d2d">n_children</a>(nodchild) = 0
<a name="l00549"></a>00549               <a class="code" href="namespacetreevars.html#368a06dc09d689328cc73ddf69490a3f">first_child</a>(nodchild) = kchild
<a name="l00550"></a>00550 
<a name="l00551"></a>00551            else if (lchild &gt; 1) then
<a name="l00552"></a>00552               newtwig = newtwig + 1
<a name="l00553"></a>00553               <a class="code" href="namespacetreevars.html#863a5294e9f064d8de564660bd1cf82d">ntwig</a> = <a class="code" href="namespacetreevars.html#863a5294e9f064d8de564660bd1cf82d">ntwig</a> + 1
<a name="l00554"></a>00554               nodchild = -<a class="code" href="namespacetreevars.html#863a5294e9f064d8de564660bd1cf82d">ntwig</a>
<a name="l00555"></a>00555               nchild = SUM( (/ (ibits(bchild,j,1),j=0,7) /) )   ! Get # children
<a name="l00556"></a>00556               <a class="code" href="namespacetreevars.html#273d43aa2e27f0f2d74fa02458d54d2d">n_children</a>( nodchild ) = nchild       
<a name="l00557"></a>00557               sub_key(1:nchild) = pack( <a class="code" href="namespacetreevars.html#e81ec702e5854eb659b60ed694d2f732">bitarr</a>(0:7), mask=(/ (btest(bchild,j),j=0,7) /) )  ! Extract child sub-keys from byte code
<a name="l00558"></a>00558               <a class="code" href="namespacetreevars.html#368a06dc09d689328cc73ddf69490a3f">first_child</a>( nodchild ) = IOR( ishft( kchild,3), sub_key(1) )              ! Construct key of 1st (grand)child
<a name="l00559"></a>00559 
<a name="l00560"></a>00560            else
<a name="l00561"></a>00561               write(<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,'(a,o15,a,i7)') '# leaves &lt;=0 for received child node ',kchild,' from PE ',ipe
<a name="l00562"></a>00562            endif
<a name="l00563"></a>00563 
<a name="l00564"></a>00564            if (<a class="code" href="namespacetreevars.html#415096877a1abe9a37d0435e96d0f30a">walk_debug</a>) write(<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,'(a,o15,a,i7,a,o13)') &amp;
<a name="l00565"></a>00565                 'Child data arrived:',kchild,' from ',ipe,' requested for key ',kparent
<a name="l00566"></a>00566 
<a name="l00567"></a>00567            ! Insert new node into local #-table
<a name="l00568"></a>00568 
<a name="l00569"></a>00569            call <a class="code" href="make__hashentry_8f90.html#bb03176f8cee39b6a08e96622d3f9017">make_hashentry</a>( kchild, nodchild, lchild, bchild, ipe, hashaddr, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> )
<a name="l00570"></a>00570 
<a name="l00571"></a>00571            <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>(hashaddr)%next = nxchild           ! Fill in special next-node pointer for non-local children
<a name="l00572"></a>00572            node_addr = <a class="code" href="get__address_8f90.html#2809b00e2dcb999b654cac13b2ffb261">key2addr</a>( kparent,'WALK: MNHE ' )
<a name="l00573"></a>00573            <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( node_addr )%childcode = IBSET(  <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( node_addr )%childcode, 9) ! Set children_HERE flag for parent node
<a name="l00574"></a>00574 
<a name="l00575"></a>00575            <a class="code" href="namespacetreevars.html#4806e1728d085ba63091689ed4e089a2">node_level</a>( nodchild ) = log(1.*kchild)/log(8.)  ! get level from keys and prestore as node property
<a name="l00576"></a>00576 
<a name="l00577"></a>00577            ! Physical properties
<a name="l00578"></a>00578 
<a name="l00579"></a>00579            <a class="code" href="namespacetreevars.html#c635f0d036ac28a9d50d9a34ce023562">charge</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#b9d8e8e7c77d33688592fb8fc698342f">q</a>
<a name="l00580"></a>00580            <a class="code" href="namespacetreevars.html#833874545f1ee36b5e31b4dfa3dc11d3">abs_charge</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%absq
<a name="l00581"></a>00581            <a class="code" href="namespacetreevars.html#4d053c9047892373590cadde565e3987">xcoc</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#4d053c9047892373590cadde565e3987">xcoc</a>
<a name="l00582"></a>00582            <a class="code" href="namespacetreevars.html#12a758eeb25f419290c25611e464f6d5">ycoc</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#12a758eeb25f419290c25611e464f6d5">ycoc</a>
<a name="l00583"></a>00583            <a class="code" href="namespacetreevars.html#670ff1fa3088f3e7884811892883a9aa">zcoc</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#670ff1fa3088f3e7884811892883a9aa">zcoc</a>
<a name="l00584"></a>00584            <a class="code" href="namespacetreevars.html#3dd15b2d32e2287f4cb38816e1aaec30">xdip</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#3dd15b2d32e2287f4cb38816e1aaec30">xdip</a>
<a name="l00585"></a>00585            <a class="code" href="namespacetreevars.html#20ca9029cf1ae376692b319a202ec4a7">ydip</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#20ca9029cf1ae376692b319a202ec4a7">ydip</a>
<a name="l00586"></a>00586            <a class="code" href="namespacetreevars.html#60326fe33c337b0da29aa828d6da9dae">zdip</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#60326fe33c337b0da29aa828d6da9dae">zdip</a>
<a name="l00587"></a>00587            <a class="code" href="namespacetreevars.html#fd025a204b3181aebd5d1833a115c037">xxquad</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#fd025a204b3181aebd5d1833a115c037">xxquad</a>
<a name="l00588"></a>00588            <a class="code" href="namespacetreevars.html#bfa839ef19e3616ca2e8aa110192d3e2">yyquad</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#bfa839ef19e3616ca2e8aa110192d3e2">yyquad</a>
<a name="l00589"></a>00589            <a class="code" href="namespacetreevars.html#1d3755f0ab2dca3b2f14d23c0c064dc2">zzquad</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#1d3755f0ab2dca3b2f14d23c0c064dc2">zzquad</a>
<a name="l00590"></a>00590            <a class="code" href="namespacetreevars.html#bb2261d5c9c8a1c62ad5a8ff6c4b1e0b">xyquad</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#bb2261d5c9c8a1c62ad5a8ff6c4b1e0b">xyquad</a>
<a name="l00591"></a>00591            <a class="code" href="namespacetreevars.html#7b35d76a055c6765224fd8776d87bff8">yzquad</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#7b35d76a055c6765224fd8776d87bff8">yzquad</a>
<a name="l00592"></a>00592            <a class="code" href="namespacetreevars.html#208c8681eab779b3d1b7105d4c7dab4a">zxquad</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#208c8681eab779b3d1b7105d4c7dab4a">zxquad</a>
<a name="l00593"></a>00593            <a class="code" href="namespacetreevars.html#79cc90053d5078b57074a25ff5889b4c">magmx</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#79cc90053d5078b57074a25ff5889b4c">magmx</a>
<a name="l00594"></a>00594            <a class="code" href="namespacetreevars.html#c5f25ca5b0581069057e0ac7b5d90939">magmy</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#c5f25ca5b0581069057e0ac7b5d90939">magmy</a>
<a name="l00595"></a>00595            <a class="code" href="namespacetreevars.html#0ffed3c46e462545a7b60d8478dc0bcc">magmz</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#0ffed3c46e462545a7b60d8478dc0bcc">magmz</a>
<a name="l00596"></a>00596            <a class="code" href="namespacetreevars.html#a638e02fa2630a6f9ee865fdcf1b733b">jx</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#a638e02fa2630a6f9ee865fdcf1b733b">jx</a>
<a name="l00597"></a>00597            <a class="code" href="namespacetreevars.html#95a1f21026d31cde85296c2d91e18b70">jy</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#95a1f21026d31cde85296c2d91e18b70">jy</a>
<a name="l00598"></a>00598            <a class="code" href="namespacetreevars.html#e2ea5dfe327e1571ddbd3bc9e2d4b79d">jz</a>( nodchild ) = <a class="code" href="namespacetreevars.html#d902932e8c109d33bc5a679c106302c2">get_child</a>(ic)%<a class="code" href="namespacetreevars.html#e2ea5dfe327e1571ddbd3bc9e2d4b79d">jz</a>
<a name="l00599"></a>00599 
<a name="l00600"></a>00600            ! Put last child onto list for post-traversal processing
<a name="l00601"></a>00601            if (nxchild == -1) then
<a name="l00602"></a>00602               nlast_child = nlast_child + 1
<a name="l00603"></a>00603               last_child(nlast_child) = kchild
<a name="l00604"></a>00604            endif
<a name="l00605"></a>00605 
<a name="l00606"></a>00606            !  Add child key to list of fetched nodes
<a name="l00607"></a>00607            <a class="code" href="namespacetreevars.html#57da86873a8ef7e030a571b7ad0263f0">nfetch_total</a>(ipe) = <a class="code" href="namespacetreevars.html#57da86873a8ef7e030a571b7ad0263f0">nfetch_total</a>(ipe) + 1
<a name="l00608"></a>00608            <a class="code" href="namespacetreevars.html#959a7ea5cb1126405dfbdbccfe52579c">sum_fetches</a>=<a class="code" href="namespacetreevars.html#959a7ea5cb1126405dfbdbccfe52579c">sum_fetches</a>+1
<a name="l00609"></a>00609            <a class="code" href="namespacetreevars.html#a22ead23f67e91c820b7e2388aa009eb">fetched_keys</a>( <a class="code" href="namespacetreevars.html#959a7ea5cb1126405dfbdbccfe52579c">sum_fetches</a> ) = kchild
<a name="l00610"></a>00610            <a class="code" href="namespacetreevars.html#b09589862184928a4ee266fea3822c47">fetched_owner</a>( <a class="code" href="namespacetreevars.html#959a7ea5cb1126405dfbdbccfe52579c">sum_fetches</a> ) = ipe
<a name="l00611"></a>00611 
<a name="l00612"></a>00612         end do
<a name="l00613"></a>00613      end do
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 
<a name="l00616"></a>00616      ! Copy defer lists to new walk lists for next tree-walk iteration
<a name="l00617"></a>00617      <a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a> = 0
<a name="l00618"></a>00618      do i=1,npshort
<a name="l00619"></a>00619         nwalk(i) = ndefer(i)   ! # deferrals still to process
<a name="l00620"></a>00620         if (nwalk(i) /= 0) then
<a name="l00621"></a>00621            <a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a> = <a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a> + 1
<a name="l00622"></a>00622            walk_list( 1:nwalk(i), i ) = defer_list( 1:nwalk(i), i )  ! Walk list to inspect
<a name="l00623"></a>00623            walk_list( nwalk(i)+1, i ) = 1        ! Last node root for correct 'next-node'
<a name="l00624"></a>00624            walk_key(<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>) = walk_list(1, i)       ! Start node for next walk
<a name="l00625"></a>00625            plist(<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>) = i                        ! Particle index
<a name="l00626"></a>00626            defer_ctr(i) = 1                        ! Deferral counter (1 ... nwalk)
<a name="l00627"></a>00627         endif
<a name="l00628"></a>00628      enddo
<a name="l00629"></a>00629 
<a name="l00630"></a>00630      nactive = count( mask = nwalk(1:npshort) /= 0 )     ! Count remaining 'active' particles - those still with deferred nodes to search
<a name="l00631"></a>00631 
<a name="l00632"></a>00632     !  call MPI_BARRIER( MPI_COMM_WORLD, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> )   ! Wait for other PEs to catch up
<a name="l00633"></a>00633 
<a name="l00634"></a>00634      ! Broadcast # remaining particles to other PEs
<a name="l00635"></a>00635 
<a name="l00636"></a>00636      call MPI_ALLGATHER( nactive, 1, MPI_INTEGER, nactives, 1, MPI_INTEGER, MPI_COMM_WORLD, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> )
<a name="l00637"></a>00637 
<a name="l00638"></a>00638      maxactive = maxval(nactives)
<a name="l00639"></a>00639      nplace_max = SUM(nplace)
<a name="l00640"></a>00640      nchild_ship_tot = SUM(nchild_ship)
<a name="l00641"></a>00641      !     call MPI_ALLREDUCE( nchild_ship_tot, max_pack, 1, MPI_INTEGER, MPI_MAX, MPI_COMM_WORLD, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> )  
<a name="l00642"></a>00642      !     call MPI_ALLREDUCE( nchild_ship_tot, sum_pack, 1, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> )  
<a name="l00643"></a>00643      !     <a class="code" href="namespacetreevars.html#959a7ea5cb1126405dfbdbccfe52579c">sum_fetches</a> = <a class="code" href="namespacetreevars.html#959a7ea5cb1126405dfbdbccfe52579c">sum_fetches</a> + nplace_max  ! Total # fetches/iteration
<a name="l00644"></a>00644      !     <a class="code" href="namespacetreevars.html#98a5e67d24ae4f0fe88492d6cf4f77a9">sum_ships</a> = <a class="code" href="namespacetreevars.html#98a5e67d24ae4f0fe88492d6cf4f77a9">sum_ships</a> + nchild_ship_tot ! Total # shipments/iteration
<a name="l00645"></a>00645 
<a name="l00646"></a>00646      if (<a class="code" href="namespacetreevars.html#af03d6c35b13db23cd43b4522df652a4">walk_summary</a> ) then
<a name="l00647"></a>00647         write (<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,'(/a,i8,a2)') 'LPEPC | Summary for traversal # ',ntraversals,' :'
<a name="l00648"></a>00648         ! Determine global max
<a name="l00649"></a>00649         call MPI_ALLREDUCE( nplace_max, max_nplace, 1, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> )
<a name="l00650"></a>00650         write (<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,'(a40,i8,a7,i8,a12,i8)') ' # inner loop iterations: ', inner_pass,', sum: ',sum_inner_pass,' previous ave: ',sum_inner_old
<a name="l00651"></a>00651         write (<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,'(a40,i8,a7,i8,a12,i8)') ' # tree hops in inner loop: ',nhops,', sum: ',sum_nhops,' previous: ',sum_nhops_old
<a name="l00652"></a>00652         write (<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,*) ' # local children shipped:     ',nchild_ship,', traversal sum:',nchild_ship_tot
<a name="l00653"></a>00653         write (<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,*) ' # non-local children fetched: ',nplace,', traversal sum:',nplace_max,' total fetches ',<a class="code" href="namespacetreevars.html#959a7ea5cb1126405dfbdbccfe52579c">sum_fetches</a>
<a name="l00654"></a>00654         write (<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,*) ' cumulative # requested keys:  ',<a class="code" href="namespacetreevars.html#c56353fcc7cc41b4f1f42d0a50cc4d64">nreqs_total</a>
<a name="l00655"></a>00655         write (<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,*) ' cumulative # fetched keys:    ',<a class="code" href="namespacetreevars.html#57da86873a8ef7e030a571b7ad0263f0">nfetch_total</a>
<a name="l00656"></a>00656 
<a name="l00657"></a>00657         write (<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,*) 'array limit',<a class="code" href="namespacetreevars.html#e34bba8fd21d4150370b72505a8b8ab7">size_fetch</a>
<a name="l00658"></a>00658 
<a name="l00659"></a>00659         write (<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,'(3(/a30,i6)/a/(2i5))') &amp;
<a name="l00660"></a>00660              'New twigs: ',newtwig, &amp;
<a name="l00661"></a>00661              'New leaves:',newleaf, &amp;
<a name="l00662"></a>00662              'New list length: ',<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>, &amp;
<a name="l00663"></a>00663              '# remaining active particles on each PE: ',SUM(nactives),MAXVAL(nactives)
<a name="l00664"></a>00664         !           '# remaining active particles on each CPU: ',(i,nactives(i+1),i=0,<a class="code" href="namespacetreevars.html#694640a77e3d8236c59add8bfa3c133b">num_pe</a>-1)
<a name="l00665"></a>00665         !        write(<a class="code" href="namespacetreevars.html#0d5a9df9963aed1fb9d6ac000ba861f1">ipefile</a>,'(a/(2i5))') 'New shortlist: ',(plist(i),pshort(plist(i)),i=1,<a class="code" href="namespacetreevars.html#0ab6b4bd7d72fb33ff1080972a6000ef">nlist</a>)
<a name="l00666"></a>00666 
<a name="l00667"></a>00667      endif
<a name="l00668"></a>00668 
<a name="l00669"></a>00669      ! Array bound checks
<a name="l00670"></a>00670      if (<a class="code" href="namespacetreevars.html#fb6610fee5c52c51b8f7cc46ce975c16">nleaf</a>&gt;.95*<a class="code" href="namespacetreevars.html#ae25455b851f03005b9ff34a1c03c139">maxleaf</a> .and. mod(<a class="code" href="namespacetreevars.html#f0c1ebe7c983f1b1061d88e367afc933">me</a>,100).eq.0) then
<a name="l00671"></a>00671         write (6,*) 'LPEPC | WARNING: tree arrays &gt;95% full on CPU ',<a class="code" href="namespacetreevars.html#f0c1ebe7c983f1b1061d88e367afc933">me</a>
<a name="l00672"></a>00672         write (6,*) 'LPEPC | <a class="code" href="namespacetreevars.html#fb6610fee5c52c51b8f7cc46ce975c16">nleaf</a> = ',<a class="code" href="namespacetreevars.html#fb6610fee5c52c51b8f7cc46ce975c16">nleaf</a>,' / ',<a class="code" href="namespacetreevars.html#ae25455b851f03005b9ff34a1c03c139">maxleaf</a>
<a name="l00673"></a>00673      endif
<a name="l00674"></a>00674      if (<a class="code" href="namespacetreevars.html#863a5294e9f064d8de564660bd1cf82d">ntwig</a>&gt;.95*<a class="code" href="namespacetreevars.html#adabb762937263c1bae53f9c21fd662e">maxtwig</a> .and. mod(<a class="code" href="namespacetreevars.html#f0c1ebe7c983f1b1061d88e367afc933">me</a>,100).eq.0) then
<a name="l00675"></a>00675         write (6,*) 'LPEPC | WARNING: tree arrays &gt;95% full on CPU ',<a class="code" href="namespacetreevars.html#f0c1ebe7c983f1b1061d88e367afc933">me</a>
<a name="l00676"></a>00676         write (6,*) 'LPEPC | <a class="code" href="namespacetreevars.html#863a5294e9f064d8de564660bd1cf82d">ntwig</a> = ',<a class="code" href="namespacetreevars.html#863a5294e9f064d8de564660bd1cf82d">ntwig</a>,' / ',<a class="code" href="namespacetreevars.html#adabb762937263c1bae53f9c21fd662e">maxtwig</a>
<a name="l00677"></a>00677      endif
<a name="l00678"></a>00678 
<a name="l00679"></a>00679      call cputime(tc1)
<a name="l00680"></a>00680      tfetch=tfetch+tc1-tw2  ! timing for 2nd half of walk
<a name="l00681"></a>00681      !POMP$ INST END(exchange)
<a name="l00682"></a>00682 
<a name="l00683"></a>00683   end do
<a name="l00684"></a>00684 
<a name="l00685"></a>00685 
<a name="l00686"></a>00686 
<a name="l00687"></a>00687   !  Determine '<a class="code" href="get__next__node_8f90.html#a175a80527b401074396161119b2d63f">next_node</a>' pointers for 'last child' list &amp; update hash table (tree).
<a name="l00688"></a>00688   !  This  ensures that traversals in next pass treat already-fetched nodes as local,
<a name="l00689"></a>00689   !  avoiding deferral list completely.
<a name="l00690"></a>00690 
<a name="l00691"></a>00691 
<a name="l00692"></a>00692   do i = 1,nlast_child
<a name="l00693"></a>00693      search_key = last_child(i)                   
<a name="l00694"></a>00694      node_addr = <a class="code" href="get__address_8f90.html#2809b00e2dcb999b654cac13b2ffb261">key2addr</a>(search_key,'WALK: NN search ')
<a name="l00695"></a>00695      <a class="code" href="namespacetreevars.html#f3784041f7cce271ebb213e4e88fb0a0">htable</a>( node_addr )%next = <a class="code" href="get__next__node_8f90.html#a175a80527b401074396161119b2d63f">next_node</a>(search_key)  !   Get next sibling, uncle, great-uncle in local tree
<a name="l00696"></a>00696   end do
<a name="l00697"></a>00697 
<a name="l00698"></a>00698   sum_inner_old = sum_inner_pass
<a name="l00699"></a>00699   !  call MPI_ALLREDUCE( sum_nhops, sum_nhops_old, 1, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> )
<a name="l00700"></a>00700   !  call MPI_ALLREDUCE( sum_inner_pass, sum_inner_old, 1, MPI_INTEGER, MPI_SUM, MPI_COMM_WORLD, <a class="code" href="namespacepepcb.html#a0d18ab20b16a2f6f7ea2d6b62caab43">ierr</a> )
<a name="l00701"></a>00701   sum_nhops_old = sum_nhops_old/<a class="code" href="namespacetreevars.html#694640a77e3d8236c59add8bfa3c133b">num_pe</a>
<a name="l00702"></a>00702   sum_inner_old = sum_inner_old/<a class="code" href="namespacetreevars.html#694640a77e3d8236c59add8bfa3c133b">num_pe</a>
<a name="l00703"></a>00703   <a class="code" href="namespacetreevars.html#66a1faa6be6c372bb5a156d17381b892">maxtraverse</a> = max(<a class="code" href="namespacetreevars.html#66a1faa6be6c372bb5a156d17381b892">maxtraverse</a>,ntraversals)
<a name="l00704"></a>00704 
<a name="l00705"></a>00705 end subroutine <a class="code" href="tree__aswalk_8f90.html#edc62302e0a6458cc8830d1d676dd759">tree_walk</a>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jan 23 16:02:50 2007 for PEPC by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7-20060810 </small></address>
</body>
</html>
